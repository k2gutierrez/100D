{"version":3,"sources":["../node_modules/@formatjs/icu-messageformat-parser/lib/error.js","../node_modules/@formatjs/icu-messageformat-parser/lib/types.js","../node_modules/@formatjs/icu-messageformat-parser/lib/regex.generated.js","../node_modules/@formatjs/icu-skeleton-parser/lib/date-time.js","../node_modules/@formatjs/icu-skeleton-parser/lib/regex.generated.js","../node_modules/@formatjs/icu-skeleton-parser/lib/number.js","../node_modules/@formatjs/icu-messageformat-parser/lib/parser.js","../node_modules/@formatjs/icu-messageformat-parser/lib/index.js","../node_modules/@formatjs/cli/src/pseudo_locale.js"],"names":["ErrorKind","TYPE","SKELETON_TYPE","isLiteralElement","el","type","literal","isArgumentElement","argument","isNumberElement","number","isDateElement","date","isTimeElement","time","isSelectElement","select","isPluralElement","plural","isPoundElement","pound","isTagElement","tag","isNumberSkeleton","isDateTimeSkeleton","dateTime","createLiteralElement","value","createNumberElement","style","SPACE_SEPARATOR_REGEX","DATE_TIME_REGEX","parseDateTimeSkeleton","skeleton","result","replace","match","len","length","era","year","RangeError","month","day","weekday","hour12","hourCycle","hour","minute","second","timeZoneName","regex_generated_WHITE_SPACE_REGEX","parser_a","FRACTION_PRECISION_REGEX","SIGNIFICANT_PRECISION_REGEX","INTEGER_WIDTH_REGEX","CONCISE_INTEGER_WIDTH_REGEX","parseSignificantPrecision","str","roundingPriority","_","g1","g2","minimumSignificantDigits","maximumSignificantDigits","parseSign","signDisplay","currencySign","parseConciseScientificAndEngineeringStem","stem","notation","slice","test","Error","minimumIntegerDigits","parseNotationOptions","opt","signOpts","parseNumberSkeleton","tokens","_i","tokens_1","token","scale","currency","options","useGrouping","maximumFractionDigits","unit","compactDisplay","Object","tslib_es6","reduce","all","currencyDisplay","unitDisplay","parseFloat","g3","g4","g5","minimumFractionDigits","trailingZeroDisplay","conciseScientificAndEngineeringOpts","SPACE_SEPARATOR_START_REGEX","RegExp","concat","source","SPACE_SEPARATOR_END_REGEX","createLocation","start","end","hasNativeStartsWith","String","prototype","startsWith","hasNativeFromCodePoint","fromCodePoint","hasNativeFromEntries","fromEntries","hasNativeCodePointAt","codePointAt","hasTrimStart","trimStart","hasTrimEnd","trimEnd","isSafeInteger","Number","n","isFinite","Math","floor","abs","REGEX_SUPPORTS_U_AND_Y","RE","exec","matchIdentifierAtIndex","s","search","position","codePoints","arguments","code","elements","i","fromCharCode","entries","obj","entries_1","_a","k","v","index","size","first","charCodeAt","flag","IDENTIFIER_PREFIX_RE_1","lastIndex","c","undefined","_isWhiteSpace","_isPatternSyntax","push","apply","parser_Parser","Parser","message","this","offset","line","column","ignoreTag","requiresOtherClause","shouldParseSkeletons","parse","parseMessage","nestingLevel","parentArgType","expectingCloseTag","isEOF","char","parseArgument","err","val","peek","error","UNMATCHED_CLOSING_TAG","clonePosition","_isAlpha","parseTag","parseLiteral","bump","location","startPosition","tagName","parseTagName","bumpSpace","bumpIf","childrenResult","children","endTagStartPosition","INVALID_TAG","closingTagNameStartPosition","UNCLOSED_TAG","startOffset","parseQuoteResult","tryParseQuote","parseUnquotedResult","tryParseUnquoted","parseLeftAngleResult","tryParseLeftAngleBracket","codepoint","ch","openingBracePosition","EXPECT_ARGUMENT_CLOSING_BRACE","EMPTY_ARGUMENT","parseIdentifierIfPossible","MALFORMED_ARGUMENT","parseArgumentOptions","startingPosition","endOffset","bumpTo","typeStartPosition","argType","typeEndPosition","EXPECT_ARGUMENT_TYPE","styleAndLocation","styleStartPosition","parseSimpleArgStyleIfPossible","EXPECT_ARGUMENT_STYLE","styleLocation","argCloseResult","tryParseArgumentClose","location_1","parseNumberSkeletonFromString","EXPECT_DATE_TIME_SKELETON","pattern","parsedOptions","typeEndPosition_1","EXPECT_SELECT_ARGUMENT_OPTIONS","identifierAndLocation","pluralOffset","EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE","tryParseDecimalInteger","INVALID_PLURAL_ARGUMENT_OFFSET_VALUE","optionsResult","tryParsePluralOrSelectOptions","location_2","pluralType","INVALID_ARGUMENT_TYPE","nestedBraces","apostrophePosition","bumpUntil","UNCLOSED_QUOTE_IN_ARGUMENT_STYLE","stringTokens_1","split","filter","x","stemAndOptions","options_1","e","INVALID_NUMBER_SKELETON","expectCloseTag","parsedFirstIdentifier","hasOtherClause","parsedSelectors","Set","selector","selectorLocation","EXPECT_PLURAL_ARGUMENT_SELECTOR","INVALID_PLURAL_ARGUMENT_SELECTOR","has","DUPLICATE_SELECT_ARGUMENT_SELECTOR","DUPLICATE_PLURAL_ARGUMENT_SELECTOR","EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT","EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT","fragmentResult","add","EXPECT_SELECT_ARGUMENT_SELECTOR","MISSING_OTHER_CLAUSE","expectNumberError","invalidNumberError","sign","hasDigits","decimal","kind","prefix","currentOffset","indexOf","targetOffset","min","nextCode","opts","SyntaxError","originalMessage","captureLocation","pruneLocation","els","forEach","__webpack_require__","d","__webpack_exports__","defineProperty","exports","generateENXB","generateENXA","generateXXHA","generateXXAC","generateXXLS","tslib_1","icu_messageformat_parser_1","msg","ast","lastChunk","pop","__spreadArray","toUpperCase","values","firstChunk","shift","ASCII","ACCENTED_ASCII","map","join","pseudoString","repeat"],"mappings":"sGAAOA,ECAAC,EAkDAC,UAWA,SAAAC,EAAAC,GACP,OAAAA,EAAAC,OAAAJ,EAAAK,QAEO,SAAAC,EAAAH,GACP,OAAAA,EAAAC,OAAAJ,EAAAO,SAEO,SAAAC,EAAAL,GACP,OAAAA,EAAAC,OAAAJ,EAAAS,OAEO,SAAAC,EAAAP,GACP,OAAAA,EAAAC,OAAAJ,EAAAW,KAEO,SAAAC,EAAAT,GACP,OAAAA,EAAAC,OAAAJ,EAAAa,KAEO,SAAAC,EAAAX,GACP,OAAAA,EAAAC,OAAAJ,EAAAe,OAEO,SAAAC,EAAAb,GACP,OAAAA,EAAAC,OAAAJ,EAAAiB,OAEO,SAAAC,EAAAf,GACP,OAAAA,EAAAC,OAAAJ,EAAAmB,MAEO,SAAAC,EAAAjB,GACP,OAAAA,EAAAC,OAAAJ,EAAAqB,IAEO,SAAAC,EAAAnB,GACP,SAAAA,GAAA,kBAAAA,KAAAC,OAAAH,EAAAQ,QAEO,SAAAc,EAAApB,GACP,SAAAA,GAAA,kBAAAA,KAAAC,OAAAH,EAAAuB,UAEO,SAAAC,EAAAC,GACP,OACAtB,KAAAJ,EAAAK,QACAqB,SAGO,SAAAC,EAAAD,EAAAE,GACP,OACAxB,KAAAJ,EAAAS,OACAiB,QACAE,UDtGA,SAAA7B,GAEAA,IAAA,iEAGAA,IAAA,mCAGAA,IAAA,2CAGAA,IAAA,+CAGAA,IAAA,iDAGAA,IAAA,iDAGAA,IAAA,qDAGAA,IAAA,2DAGAA,IAAA,mDAGAA,IAAA,0DAGAA,IAAA,wEAGAA,IAAA,oEAGAA,IAAA,8EAGAA,IAAA,gFAGAA,IAAA,sEAGAA,IAAA,sEAGAA,IAAA,wFAMAA,IAAA,wFAGAA,IAAA,wEAMAA,IAAA,4EAKAA,IAAA,4EAGAA,IAAA,gDAGAA,IAAA,8BAGAA,IAAA,wCAGAA,IAAA,kDAGAA,IAAA,gCArFA,CAsFCA,MAAA,KCtFD,SAAAC,GAIAA,IAAA,qBAKAA,IAAA,uBAKAA,IAAA,mBAKAA,IAAA,eAKAA,IAAA,eAKAA,IAAA,mBAKAA,IAAA,mBAMAA,IAAA,iBAKAA,IAAA,aA7CA,CA8CCA,MAAA,KAID,SAAAC,GACAA,IAAA,mBACAA,IAAA,uBAFA,CAGCA,MAAA,KCtDM,IAAA4B,EAAA,+CCIPC,EAAA,4KAQO,SAAAC,EAAAC,GACP,IAAAC,EAAA,GA8IA,OA7IAD,EAAAE,QAAAJ,EAAA,SAAAK,GACA,IAAAC,EAAAD,EAAAE,OAEA,OAAAF,EAAA,IAEA,QACAF,EAAAK,IAAA,IAAAF,EAAA,WAAAA,EAAA,iBACA,MAGA,QACAH,EAAAM,KAAA,IAAAH,EAAA,oBACA,MAEA,QACA,QACA,QACA,QACA,UAAAI,WAAA,gEAGA,QACA,QACA,UAAAA,WAAA,8CAGA,QACA,QACAP,EAAAQ,MAAA,8CAAAL,EAAA,GACA,MAGA,QACA,QACA,UAAAI,WAAA,2CAEA,QACAP,EAAAS,IAAA,sBAAAN,EAAA,GACA,MAEA,QACA,QACA,QACA,UAAAI,WAAA,6DAGA,QACAP,EAAAU,QAAA,IAAAP,EAAA,YAAAA,EAAA,iBACA,MAEA,QACA,GAAAA,EAAA,EACA,UAAAI,WAAA,iDAGAP,EAAAU,QAAA,kCAAAP,EAAA,GACA,MAEA,QACA,GAAAA,EAAA,EACA,UAAAI,WAAA,iDAGAP,EAAAU,QAAA,kCAAAP,EAAA,GACA,MAGA,QAEAH,EAAAW,QAAA,EACA,MAEA,QAEA,QAEA,UAAAJ,WAAA,8DAGA,QACAP,EAAAY,UAAA,MACAZ,EAAAa,KAAA,sBAAAV,EAAA,GACA,MAEA,QACAH,EAAAY,UAAA,MACAZ,EAAAa,KAAA,sBAAAV,EAAA,GACA,MAEA,QACAH,EAAAY,UAAA,MACAZ,EAAAa,KAAA,sBAAAV,EAAA,GACA,MAEA,QACAH,EAAAY,UAAA,MACAZ,EAAAa,KAAA,sBAAAV,EAAA,GACA,MAEA,QACA,QACA,QACA,UAAAI,WAAA,oEAGA,QACAP,EAAAc,OAAA,sBAAAX,EAAA,GACA,MAGA,QACAH,EAAAe,OAAA,sBAAAZ,EAAA,GACA,MAEA,QACA,QACA,UAAAI,WAAA,8DAGA,QAEAP,EAAAgB,aAAAb,EAAA,iBACA,MAEA,QAEA,QAEA,QAEA,QAEA,QAEA,QAEA,UAAAI,WAAA,wEAGA,WAEAP,EC3JO,IAAIiB,EAAiB,wCC4C5B,IC7CIC,ED6CJC,EAAA,mCACAC,EAAA,wBACAC,EAAA,0BACAC,EAAA,SAEA,SAAAC,EAAAC,GACA,IAAAxB,EAAA,GA2BA,MAzBA,MAAAwB,IAAApB,OAAA,GACAJ,EAAAyB,iBAAA,gBACG,MAAAD,IAAApB,OAAA,KACHJ,EAAAyB,iBAAA,iBAGAD,EAAAvB,QAAAmB,EAAA,SAAAM,EAAAC,EAAAC,GAiBA,MAfA,kBAAAA,GACA5B,EAAA6B,yBAAAF,EAAAvB,OACAJ,EAAA8B,yBAAAH,EAAAvB,QAEA,MAAAwB,EACA5B,EAAA6B,yBAAAF,EAAAvB,OAEA,MAAAuB,EAAA,GACA3B,EAAA8B,yBAAAH,EAAAvB,QAGAJ,EAAA6B,yBAAAF,EAAAvB,OACAJ,EAAA8B,yBAAAH,EAAAvB,QAAA,kBAAAwB,IAAAxB,OAAA,IAGA,KAEAJ,EAGA,SAAA+B,EAAAP,GACA,OAAAA,GACA,gBACA,OACAQ,YAAA,QAGA,sBACA,SACA,OACAC,aAAA,cAGA,kBACA,SACA,OACAD,YAAA,UAGA,6BACA,UACA,OACAA,YAAA,SACAC,aAAA,cAGA,uBACA,SACA,OACAD,YAAA,cAGA,kCACA,UACA,OACAA,YAAA,aACAC,aAAA,cAGA,iBACA,SACA,OACAD,YAAA,UAKA,SAAAE,EAAAC,GAEA,IAAAnC,EAcA,GAZA,MAAAmC,EAAA,UAAAA,EAAA,IACAnC,EAAA,CACAoC,SAAA,eAEAD,IAAAE,MAAA,IACG,MAAAF,EAAA,KACHnC,EAAA,CACAoC,SAAA,cAEAD,IAAAE,MAAA,IAGArC,EAAA,CACA,IAAAgC,EAAAG,EAAAE,MAAA,KAUA,GARA,OAAAL,GACAhC,EAAAgC,YAAA,SACAG,IAAAE,MAAA,IACK,OAAAL,IACLhC,EAAAgC,YAAA,aACAG,IAAAE,MAAA,KAGAf,EAAAgB,KAAAH,GACA,UAAAI,MAAA,6CAGAvC,EAAAwC,qBAAAL,EAAA/B,OAGA,OAAAJ,EAGA,SAAAyC,EAAAC,GACA,IACAC,EAAAZ,EAAAW,GAEA,OAAAC,GAHA,GAcO,SAAAC,EAAAC,GAGP,IAFA,IAAA7C,EAAA,GAEA8C,EAAA,EAAAC,EAAAF,EAAqCC,EAAAC,EAAA3C,OAAsB0C,IAAA,CAC3D,IAAAE,EAAAD,EAAAD,GAEA,OAAAE,EAAAb,MACA,cACA,QACAnC,EAAAL,MAAA,UACA,SAEA,YACAK,EAAAL,MAAA,UACAK,EAAAiD,MAAA,IACA,SAEA,eACAjD,EAAAL,MAAA,WACAK,EAAAkD,SAAAF,EAAAG,QAAA,GACA,SAEA,gBACA,SACAnD,EAAAoD,aAAA,EACA,SAEA,wBACA,QACApD,EAAAqD,sBAAA,EACA,SAEA,mBACA,WACArD,EAAAL,MAAA,OACAK,EAAAsD,KAAAN,EAAAG,QAAA,GA7KAlD,QAAA,cA8KA,SAEA,oBACA,QACAD,EAAAoC,SAAA,UACApC,EAAAuD,eAAA,QACA,SAEA,mBACA,SACAvD,EAAAoC,SAAA,UACApC,EAAAuD,eAAA,OACA,SAEA,iBACAvD,EAAiBwD,OAAAC,EAAA,SAAAD,CAASA,OAAAC,EAAA,SAAAD,CAASA,OAAAC,EAAA,SAAAD,CAAQ,GAAGxD,GAAA,CAC9CoC,SAAA,eACSY,EAAAG,QAAAO,OAAA,SAAAC,EAAAjB,GACT,OAAiBc,OAAAC,EAAA,SAAAD,CAASA,OAAAC,EAAA,SAAAD,CAAQ,GAAGG,GAAAlB,EAAAC,KAC5B,KACT,SAEA,kBACA1C,EAAiBwD,OAAAC,EAAA,SAAAD,CAASA,OAAAC,EAAA,SAAAD,CAASA,OAAAC,EAAA,SAAAD,CAAQ,GAAGxD,GAAA,CAC9CoC,SAAA,gBACSY,EAAAG,QAAAO,OAAA,SAAAC,EAAAjB,GACT,OAAiBc,OAAAC,EAAA,SAAAD,CAASA,OAAAC,EAAA,SAAAD,CAAQ,GAAGG,GAAAlB,EAAAC,KAC5B,KACT,SAEA,sBACA1C,EAAAoC,SAAA,WACA,SAGA,wBACApC,EAAA4D,gBAAA,eACA5D,EAAA6D,YAAA,SACA,SAEA,uBACA7D,EAAA4D,gBAAA,OACA5D,EAAA6D,YAAA,QACA,SAEA,2BACA7D,EAAA4D,gBAAA,OACA5D,EAAA6D,YAAA,OACA,SAEA,0BACA7D,EAAA4D,gBAAA,SACA,SAEA,YACA5D,EAAAiD,MAAAa,WAAAd,EAAAG,QAAA,IACA,SAGA,oBACA,GAAAH,EAAAG,QAAA/C,OAAA,EACA,UAAAG,WAAA,4DAGAyC,EAAAG,QAAA,GAAAlD,QAAAoB,EAAA,SAAAK,EAAAC,EAAAC,EAAAmC,EAAAC,EAAAC,GACA,GAAAtC,EACA3B,EAAAwC,qBAAAZ,EAAAxB,WACW,IAAA2D,GAAAC,EACX,UAAAzB,MAAA,sDACW,GAAA0B,EACX,UAAA1B,MAAA,oDAGA,WAEA,SAIA,GAAAjB,EAAAgB,KAAAU,EAAAb,MACAnC,EAAAwC,qBAAAQ,EAAAb,KAAA/B,YAIA,GAAAe,EAAAmB,KAAAU,EAAAb,MAAA,CAIA,GAAAa,EAAAG,QAAA/C,OAAA,EACA,UAAAG,WAAA,iEAGAyC,EAAAb,KAAAlC,QAAAkB,EAAA,SAAAO,EAAAC,EAAAC,EAAAmC,EAAAC,EAAAC,GAgBA,MAdA,MAAArC,EACA5B,EAAAkE,sBAAAvC,EAAAvB,OAEA2D,GAAA,MAAAA,EAAA,GACA/D,EAAAqD,sBAAAU,EAAA3D,OAEA4D,GAAAC,GACAjE,EAAAkE,sBAAAF,EAAA5D,OACAJ,EAAAqD,sBAAAW,EAAA5D,OAAA6D,EAAA7D,SAEAJ,EAAAkE,sBAAAvC,EAAAvB,OACAJ,EAAAqD,sBAAA1B,EAAAvB,QAGA,KAEA,IAAAsC,EAAAM,EAAAG,QAAA,GAEA,MAAAT,EACA1C,EAAiBwD,OAAAC,EAAA,SAAAD,CAASA,OAAAC,EAAA,SAAAD,CAAQ,GAAGxD,GAAA,CACrCmE,oBAAA,mBAEOzB,IACP1C,EAAiBwD,OAAAC,EAAA,SAAAD,CAASA,OAAAC,EAAA,SAAAD,CAAQ,GAAGxD,GAAAuB,EAAAmB,UAOrC,GAAAtB,EAAAkB,KAAAU,EAAAb,MACAnC,EAAewD,OAAAC,EAAA,SAAAD,CAASA,OAAAC,EAAA,SAAAD,CAAQ,GAAGxD,GAAAuB,EAAAyB,EAAAb,WADnC,CAKA,IAAAQ,EAAAZ,EAAAiB,EAAAb,MAEAQ,IACA3C,EAAewD,OAAAC,EAAA,SAAAD,CAASA,OAAAC,EAAA,SAAAD,CAAQ,GAAGxD,GAAA2C,IAGnC,IAAAyB,EAAAlC,EAAAc,EAAAb,MAEAiC,IACApE,EAAewD,OAAAC,EAAA,SAAAD,CAASA,OAAAC,EAAA,SAAAD,CAAQ,GAAGxD,GAAAoE,KAInC,OAAApE,EC/VA,IAAAqE,EAAA,IAAAC,OAAA,IAAAC,OAAwD3E,EAAqB4E,OAAA,MAC7EC,EAAA,IAAAH,OAAA,GAAAC,OAAqD3E,EAAqB4E,OAAA,OAE1E,SAAAE,EAAAC,EAAAC,GACA,OACAD,QACAC,OAMA,IAAAC,IAAAC,OAAAC,UAAAC,WACAC,IAAAH,OAAAI,cACAC,IAAA3B,OAAA4B,YACAC,IAAAP,OAAAC,UAAAO,YACAC,IAAAT,OAAAC,UAAAS,UACAC,IAAAX,OAAAC,UAAAW,QAEAC,IADAC,OAAAD,cACAC,OAAAD,cAAA,SAAAE,GACA,wBAAAA,GAAAC,SAAAD,IAAAE,KAAAC,MAAAH,QAAAE,KAAAE,IAAAJ,IAAA,kBAGAK,GAAA,EAEA,IASAA,EAAuF,OAAxD,QAAFhF,EAR7BiF,EAAA,4CAAqD,MAQtBC,KAAA,YAA+B,IAAFlF,OAAE,EAAuBA,EAAE,IACtF,MAAAQ,IACDwE,GAAA,EAGA,IA6EAG,EA7EArB,EAAAH,EACA,SAAAyB,EAAAC,EAAAC,GACA,OAAAF,EAAAtB,WAAAuB,EAAAC,IAEA,SAAAF,EAAAC,EAAAC,GACA,OAAAF,EAAAjE,MAAAmE,IAAAD,EAAAnG,UAAAmG,GAEArB,EAAAD,EAAAH,OAAAI,cACA,WAGA,IAFA,IAAAuB,EAAA,GAEA3D,EAAA,EAAkBA,EAAA4D,UAAAtG,OAAuB0C,IACzC2D,EAAA3D,GAAA4D,UAAA5D,GAQA,IALA,IAGA6D,EAHAC,EAAA,GACAxG,EAAAqG,EAAArG,OACAyG,EAAA,EAGAzG,EAAAyG,GAAA,CAEA,IADAF,EAAAF,EAAAI,MACA,cAAAtG,WAAAoG,EAAA,8BACAC,GAAAD,EAAA,MAAA7B,OAAAgC,aAAAH,GAAA7B,OAAAgC,aAAA,QAAAH,GAAA,YAAAA,EAAA,YAGA,OAAAC,GAEAxB,EACAD,EAAA3B,OAAA4B,YACA,SAAA2B,GAGA,IAFA,IAAAC,EAAA,GAEAlE,EAAA,EAAAmE,EAAAF,EAAuCjE,EAAAmE,EAAA7G,OAAuB0C,IAAA,CAC9D,IAAAoE,EAAAD,EAAAnE,GACAqE,EAAAD,EAAA,GACAE,EAAAF,EAAA,GACAF,EAAAG,GAAAC,EAGA,OAAAJ,GAEA1B,EAAAD,EACA,SAAAiB,EAAAe,GACA,OAAAf,EAAAhB,YAAA+B,IAEA,SAAAf,EAAAe,GACA,IAAAC,EAAAhB,EAAAlG,OAEA,KAAAiH,EAAA,GAAAA,GAAAC,GAAA,CAIA,IACAvG,EADAwG,EAAAjB,EAAAkB,WAAAH,GAEA,OAAAE,EAAA,OAAAA,EAAA,OAAAF,EAAA,IAAAC,IAAAvG,EAAAuF,EAAAkB,WAAAH,EAAA,WAAAtG,EAAA,MAAAwG,EAAAxG,EAAA,OAAAwG,EAAA,mBAEA/B,EAAAD,EACA,SAAAe,GACA,OAAAA,EAAAd,aAEA,SAAAc,GACA,OAAAA,EAAArG,QAAAoE,EAAA,KAEAqB,EAAAD,EACA,SAAAa,GACA,OAAAA,EAAAZ,WAEA,SAAAY,GACA,OAAAA,EAAArG,QAAAwE,EAAA,KAGA,SAAA0B,EAAAG,EAAAmB,GACA,WAAAnD,OAAAgC,EAAAmB,GAMA,GAAAvB,EAAA,CAEA,IAAAwB,EAAAvB,EAAA,4CAAyE,MAEzEE,EAAA,SAAAC,EAAAe,GACA,IAAAH,EAIA,OAFAQ,EAAAC,UAAAN,EAEA,QAAAH,EADAQ,EAAAtB,KAAAE,GACA,cAAAY,IAAA,SAIAb,EAAA,SAAAC,EAAAe,GAGA,IAFA,IAAAnH,EAAA,KAEA,CACA,IAAA0H,EAAAtC,EAAAgB,EAAAe,GAEA,QAAAQ,IAAAD,GAAAE,GAAAF,IAAAG,GAAAH,GACA,MAGA1H,EAAA8H,KAAAJ,GACAP,GAAAO,GAAA,UAGA,OAAA1C,EAAA+C,WAAA,EAAA/H,IAIA,IAAIgI,GAEJ,WACA,SAAAC,EAAAC,EAAAjF,QACA,IAAAA,IACAA,EAAA,IAGAkF,KAAAD,UACAC,KAAA7B,SAAA,CACA8B,OAAA,EACAC,KAAA,EACAC,OAAA,GAEAH,KAAAI,YAAAtF,EAAAsF,UACAJ,KAAAK,sBAAAvF,EAAAuF,oBACAL,KAAAM,uBAAAxF,EAAAwF,qBA6/BA,OA1/BAR,EAAApD,UAAA6D,MAAA,WACA,OAAAP,KAAAC,SACA,MAAA/F,MAAA,gCAGA,OAAA8F,KAAAQ,aAAA,UAGAV,EAAApD,UAAA8D,aAAA,SAAAC,EAAAC,EAAAC,GAGA,IAFA,IAAApC,EAAA,IAEAyB,KAAAY,SAAA,CACA,IAAAC,EAAAb,KAAAa,OAEA,SAAAA,EAEA,CAGA,IAFAlJ,EAAAqI,KAAAc,cAAAL,EAAAE,IAEAI,IACA,OAAApJ,EAGA4G,EAAAoB,KAAAhI,EAAAqJ,SACO,UAAAH,GAEPJ,EAAA,EACA,MACO,QAAAI,GAEP,WAAAH,GAAA,kBAAAA,EAOO,SAAAG,IAEPb,KAAAI,WAAA,KAAAJ,KAAAiB,OACA,CACA,GAAAN,EACA,MAEA,OAAAX,KAAAkB,MAA4BzL,EAAS0L,sBAAA9E,EAAA2D,KAAAoB,gBAAApB,KAAAoB,kBAE9B,QAAAP,IAEPb,KAAAI,WAAAiB,GAAArB,KAAAiB,QAAA,IAGA,IAFAtJ,EAAAqI,KAAAsB,SAAAb,EAAAC,IAEAK,IACA,OAAApJ,EAGA4G,EAAAoB,KAAAhI,EAAAqJ,SACO,CACP,IAAArJ,EAEA,IAFAA,EAAAqI,KAAAuB,aAAAd,EAAAC,IAEAK,IACA,OAAApJ,EAGA4G,EAAAoB,KAAAhI,EAAAqJ,UAjCA,CACA,IAAA7C,EAAA6B,KAAAoB,gBACApB,KAAAwB,OACAjD,EAAAoB,KAAA,CACA7J,KAAgBJ,EAAImB,MACpB4K,SAAApF,EAAA8B,EAAA6B,KAAAoB,qBAgCA,OACAJ,IAAAzC,EACAwC,IAAA,OAuBAjB,EAAApD,UAAA4E,SAAA,SAAAb,EAAAC,GACA,IAAAgB,EAAA1B,KAAAoB,gBACApB,KAAAwB,OAEA,IAAAG,EAAA3B,KAAA4B,eAGA,GAFA5B,KAAA6B,YAEA7B,KAAA8B,OAAA,MAEA,OACAd,IAAA,CACAlL,KAAgBJ,EAAIK,QACpBqB,MAAA,IAAA8E,OAAAyF,EAAA,MACAF,SAAApF,EAAAqF,EAAA1B,KAAAoB,kBAEAL,IAAA,MAEK,GAAAf,KAAA8B,OAAA,MACL,IAAAC,EAAA/B,KAAAQ,aAAAC,EAAA,EAAAC,GAAA,GAEA,GAAAqB,EAAAhB,IACA,OAAAgB,EAGA,IAAAC,EAAAD,EAAAf,IAEAiB,EAAAjC,KAAAoB,gBAEA,GAAApB,KAAA8B,OAAA,OACA,GAAA9B,KAAAY,UAAAS,GAAArB,KAAAa,QACA,OAAAb,KAAAkB,MAA4BzL,EAASyM,YAAA7F,EAAA4F,EAAAjC,KAAAoB,kBAGrC,IAAAe,EAAAnC,KAAAoB,gBAGA,OAAAO,IAFA3B,KAAA4B,eAGA5B,KAAAkB,MAA4BzL,EAAS0L,sBAAA9E,EAAA8F,EAAAnC,KAAAoB,mBAGrCpB,KAAA6B,YAEA7B,KAAA8B,OAAA,KAIA,CACAd,IAAA,CACAlL,KAAkBJ,EAAIqB,IACtBK,MAAAuK,EACAK,WACAP,SAAApF,EAAAqF,EAAA1B,KAAAoB,kBAEAL,IAAA,MAVAf,KAAAkB,MAA4BzL,EAASyM,YAAA7F,EAAA4F,EAAAjC,KAAAoB,mBAarC,OAAApB,KAAAkB,MAA0BzL,EAAS2M,aAAA/F,EAAAqF,EAAA1B,KAAAoB,kBAGnC,OAAApB,KAAAkB,MAAwBzL,EAASyM,YAAA7F,EAAAqF,EAAA1B,KAAAoB,mBAQjCtB,EAAApD,UAAAkF,aAAA,WACA,IA+2BArC,EA/2BA8C,EAAArC,KAAAC,SAGA,IAFAD,KAAAwB,QAEAxB,KAAAY,UA62BA,MADArB,EA52BAS,KAAAa,SA+2BA,KAAAtB,GAEAA,GAAA,IAAAA,GAAA,IAEA,KAAAA,GAEAA,GAAA,IAAAA,GAAA,KAEAA,GAAA,IAAAA,GAAA,IAEA,KAAAA,MAAA,KAAAA,GAAA,KAAAA,GAAA,KAAAA,GAAA,KAAAA,GAAA,KAAAA,GAAA,KAAAA,GAAA,KAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,SAx3BAS,KAAAwB,OAGA,OAAAxB,KAAAD,QAAA/F,MAAAqI,EAAArC,KAAAC,WAGAH,EAAApD,UAAA6E,aAAA,SAAAd,EAAAC,GAIA,IAHA,IAAApE,EAAA0D,KAAAoB,gBACAhK,EAAA,KAEA,CACA,IAAAkL,EAAAtC,KAAAuC,cAAA7B,GAEA,GAAA4B,EACAlL,GAAAkL,MADA,CAKA,IAAAE,EAAAxC,KAAAyC,iBAAAhC,EAAAC,GAEA,GAAA8B,EACApL,GAAAoL,MADA,CAKA,IAAAE,EAAA1C,KAAA2C,2BAEA,IAAAD,EAKA,MAJAtL,GAAAsL,IAOA,IAAAjB,EAAApF,EAAAC,EAAA0D,KAAAoB,iBACA,OACAJ,IAAA,CACAlL,KAAcJ,EAAIK,QAClBqB,QACAqK,YAEAV,IAAA,OAIAjB,EAAApD,UAAAiG,yBAAA,WACA,OAAA3C,KAAAY,SAAA,KAAAZ,KAAAa,SAEAb,KAAAI,YAozBAiB,GADAuB,EAlzBA5C,KAAAiB,QAAA,IAmzBA,KAAA2B,GA7yBA,MALA5C,KAAAwB,OAEA,KA+yBA,IAAAoB,GAnyBA9C,EAAApD,UAAA6F,cAAA,SAAA7B,GACA,GAAAV,KAAAY,SAAA,KAAAZ,KAAAa,OAGA,YAKA,OAAAb,KAAAiB,QACA,QAMA,OAFAjB,KAAAwB,OACAxB,KAAAwB,OACA,IAGA,SACA,QACA,QACA,SACA,MAEA,QAEA,cAAAd,GAAA,kBAAAA,EACA,MAGA,YAEA,QACA,YAGAV,KAAAwB,OAEA,IAAApD,EAAA,CAAA4B,KAAAa,QAIA,IAFAb,KAAAwB,QAEAxB,KAAAY,SAAA,CACA,IAAAiC,EAAA7C,KAAAa,OAEA,QAAAgC,EAEA,CACA,QAAA7C,KAAAiB,OAMS,CAETjB,KAAAwB,OACA,MANApD,EAAAuB,KAAA,IAEAK,KAAAwB,YAOApD,EAAAuB,KAAAkD,GAGA7C,KAAAwB,OAGA,OAAA3E,EAAA+C,WAAA,EAAAxB,IAGA0B,EAAApD,UAAA+F,iBAAA,SAAAhC,EAAAC,GACA,GAAAV,KAAAY,QACA,YAGA,IAAAiC,EAAA7C,KAAAa,OAEA,YAAAgC,GAEA,MAAAA,GAEA,KAAAA,IAEA,WAAAnC,GAAA,kBAAAA,IAAA,MAAAmC,GAEApC,EAAA,EACA,MAEAT,KAAAwB,OACA3E,EAAAgG,KAIA/C,EAAApD,UAAAoE,cAAA,SAAAL,EAAAE,GACA,IAAAmC,EAAA9C,KAAAoB,gBAKA,GAJApB,KAAAwB,OAEAxB,KAAA6B,YAEA7B,KAAAY,QACA,OAAAZ,KAAAkB,MAAwBzL,EAASsN,8BAAA1G,EAAAyG,EAAA9C,KAAAoB,kBAGjC,SAAApB,KAAAa,OAIA,OADAb,KAAAwB,OACAxB,KAAAkB,MAAwBzL,EAASuN,eAAA3G,EAAAyG,EAAA9C,KAAAoB,kBAIjC,IAAAhK,EAAA4I,KAAAiD,4BAAA7L,MAEA,IAAAA,EACA,OAAA4I,KAAAkB,MAAwBzL,EAASyN,mBAAA7G,EAAAyG,EAAA9C,KAAAoB,kBAKjC,GAFApB,KAAA6B,YAEA7B,KAAAY,QACA,OAAAZ,KAAAkB,MAAwBzL,EAASsN,8BAAA1G,EAAAyG,EAAA9C,KAAAoB,kBAGjC,OAAApB,KAAAa,QAEA,SAMA,OAFAb,KAAAwB,OAEA,CACAR,IAAA,CACAlL,KAAoBJ,EAAIO,SAExBmB,QACAqK,SAAApF,EAAAyG,EAAA9C,KAAAoB,kBAEAL,IAAA,MAKA,QAQA,OAJAf,KAAAwB,OAEAxB,KAAA6B,YAEA7B,KAAAY,QACAZ,KAAAkB,MAA8BzL,EAASsN,8BAAA1G,EAAAyG,EAAA9C,KAAAoB,kBAGvCpB,KAAAmD,qBAAA1C,EAAAE,EAAAvJ,EAAA0L,GAGA,QACA,OAAA9C,KAAAkB,MAA0BzL,EAASyN,mBAAA7G,EAAAyG,EAAA9C,KAAAoB,oBASnCtB,EAAApD,UAAAuG,0BAAA,WACA,IAAAG,EAAApD,KAAAoB,gBACAiB,EAAArC,KAAAC,SACA7I,EAAA4G,EAAAgC,KAAAD,QAAAsC,GACAgB,EAAAhB,EAAAjL,EAAAW,OAIA,OAHAiI,KAAAsD,OAAAD,GAGA,CACAjM,QACAqK,SAHApF,EAAA+G,EADApD,KAAAoB,mBAQAtB,EAAApD,UAAAyG,qBAAA,SAAA1C,EAAAE,EAAAvJ,EAAA0L,GACA,IAAAjE,EAKA0E,EAAAvD,KAAAoB,gBACAoC,EAAAxD,KAAAiD,4BAAA7L,MACAqM,EAAAzD,KAAAoB,gBAEA,OAAAoC,GACA,OAEA,OAAAxD,KAAAkB,MAA0BzL,EAASiO,qBAAArH,EAAAkH,EAAAE,IAEnC,aACA,WACA,WAKAzD,KAAA6B,YACA,IAAA8B,EAAA,KAEA,GAAA3D,KAAA8B,OAAA,MACA9B,KAAA6B,YACA,IAAA+B,EAAA5D,KAAAoB,gBAGA,IAFAzJ,EAAAqI,KAAA6D,iCAEA9C,IACA,OAAApJ,EAKA,QAFAL,EAAA+F,EAAA1F,EAAAqJ,MAEAjJ,OACA,OAAAiI,KAAAkB,MAAgCzL,EAASqO,sBAAAzH,EAAA2D,KAAAoB,gBAAApB,KAAAoB,kBAIzCuC,EAAA,CACArM,QACAyM,cAHA1H,EAAAuH,EAAA5D,KAAAoB,kBASA,IAFA4C,EAAAhE,KAAAiE,sBAAAnB,IAEA/B,IACA,OAAAiD,EAGA,IAAAE,EAAA7H,EAAAyG,EAAA9C,KAAAoB,iBAEA,GAAAuC,GAAAhH,EAAA,OAAAgH,QAAA,IAAAA,OAAA,EAAAA,EAAArM,MAAA,SAEA,IAAAI,EAAAyF,EAAAwG,EAAArM,MAAA0C,MAAA,IAEA,cAAAwJ,EAGA,OAFA7L,EAAAqI,KAAAmE,8BAAAzM,EAAAiM,EAAAI,gBAEAhD,IACApJ,EAGA,CACAqJ,IAAA,CACAlL,KAAwBJ,EAAIS,OAC5BiB,QACAqK,SAAAyC,EACA5M,MAAAK,EAAAqJ,KAEAD,IAAA,MAGA,OAAArJ,EAAAK,OACA,OAAAiI,KAAAkB,MAAkCzL,EAAS2O,0BAAAF,GAG3C,IAAA5M,EAAA,CACAxB,KAAsBH,EAAauB,SACnCmN,QAAA3M,EACA+J,SAAAkC,EAAAI,cACAO,cAAAtE,KAAAM,qBAA2D7I,EAAqBC,GAAA,IAGhF,OACAsJ,IAAA,CACAlL,KAHA,SAAA0N,EAA8C9N,EAAIW,KAAQX,EAAIa,KAI9Da,QACAqK,SAAAyC,EACA5M,SAEAyJ,IAAA,MAMA,OACAC,IAAA,CACAlL,KAAA,WAAA0N,EAA2C9N,EAAIS,OAAA,SAAAqN,EAA+B9N,EAAIW,KAAQX,EAAIa,KAC9Fa,QACAqK,SAAAyC,EACA5M,MAAA,QAAAuH,EAAA,OAAA8E,QAAA,IAAAA,OAAA,EAAAA,EAAArM,aAAA,IAAAuH,IAAA,MAEAkC,IAAA,MAIA,aACA,oBACA,aAKA,IAAAwD,EAAAvE,KAAAoB,gBAGA,GAFApB,KAAA6B,aAEA7B,KAAA8B,OAAA,KACA,OAAA9B,KAAAkB,MAA8BzL,EAAS+O,+BAAAnI,EAAAkI,EAAmEpJ,OAAAC,EAAA,SAAAD,CAAQ,GAAGoJ,KAGrHvE,KAAA6B,YASA,IAAA4C,EAAAzE,KAAAiD,4BACAyB,EAAA,EAEA,cAAAlB,GAAA,WAAAiB,EAAArN,MAAA,CACA,IAAA4I,KAAA8B,OAAA,KACA,OAAA9B,KAAAkB,MAAgCzL,EAASkP,oCAAAtI,EAAA2D,KAAAoB,gBAAApB,KAAAoB,kBAIzC,IAAAzJ,EAEA,GAHAqI,KAAA6B,aACAlK,EAAAqI,KAAA4E,uBAAqDnP,EAASkP,oCAAsClP,EAASoP,uCAE7G9D,IACA,OAAApJ,EAIAqI,KAAA6B,YACA4C,EAAAzE,KAAAiD,4BACAyB,EAAA/M,EAAAqJ,IAGA,IAMAgD,EANAc,EAAA9E,KAAA+E,8BAAAtE,EAAA+C,EAAA7C,EAAA8D,GAEA,GAAAK,EAAA/D,IACA,OAAA+D,EAKA,IAFAd,EAAAhE,KAAAiE,sBAAAnB,IAEA/B,IACA,OAAAiD,EAGA,IAAAgB,EAAA3I,EAAAyG,EAAA9C,KAAAoB,iBAEA,iBAAAoC,EACA,CACAxC,IAAA,CACAlL,KAAsBJ,EAAIe,OAC1BW,QACA0D,QAAAiC,EAAA+H,EAAA9D,KACAS,SAAAuD,GAEAjE,IAAA,MAGA,CACAC,IAAA,CACAlL,KAAsBJ,EAAIiB,OAC1BS,QACA0D,QAAAiC,EAAA+H,EAAA9D,KACAf,OAAAyE,EACAO,WAAA,WAAAzB,EAAA,qBACA/B,SAAAuD,GAEAjE,IAAA,MAKA,QACA,OAAAf,KAAAkB,MAA0BzL,EAASyP,sBAAA7I,EAAAkH,EAAAE,MAInC3D,EAAApD,UAAAuH,sBAAA,SAAAnB,GAGA,OAAA9C,KAAAY,SAAA,MAAAZ,KAAAa,OAGAb,KAAAkB,MAAwBzL,EAASsN,8BAAA1G,EAAAyG,EAAA9C,KAAAoB,mBAGjCpB,KAAAwB,OAEA,CACAR,KAAA,EACAD,IAAA,QAQAjB,EAAApD,UAAAmH,8BAAA,WAIA,IAHA,IAAAsB,EAAA,EACAzD,EAAA1B,KAAAoB,iBAEApB,KAAAY,SAAA,CAGA,OAFAZ,KAAAa,QAGA,QAMAb,KAAAwB,OACA,IAAA4D,EAAApF,KAAAoB,gBAEA,IAAApB,KAAAqF,UAAA,KACA,OAAArF,KAAAkB,MAAgCzL,EAAS6P,iCAAAjJ,EAAA+I,EAAApF,KAAAoB,kBAGzCpB,KAAAwB,OACA,MAGA,SAIA2D,GAAA,EACAnF,KAAAwB,OACA,MAGA,SAIA,KAAA2D,EAAA,GAGA,OACAnE,IAAAhB,KAAAD,QAAA/F,MAAA0H,EAAAzB,OAAAD,KAAAC,UACAc,IAAA,MAJAoE,GAAA,EAQA,MAGA,QACAnF,KAAAwB,QAKA,OACAR,IAAAhB,KAAAD,QAAA/F,MAAA0H,EAAAzB,OAAAD,KAAAC,UACAc,IAAA,OAIAjB,EAAApD,UAAAyH,8BAAA,SAAAzM,EAAA+J,GACA,IAAAjH,EAAA,GAEA,IACAA,EDt2BO,SAAA9C,GACP,OAAAA,EAAAK,OACA,UAAAmC,MAAA,mCASA,IALA,IAGAM,EAAA,GAEAC,EAAA,EAAA8K,EALA7N,EAAA8N,MAAoC5M,GAAiB6M,OAAA,SAAAC,GACrD,OAAAA,EAAA3N,OAAA,IAIiD0C,EAAA8K,EAAAxN,OAA4B0C,IAAA,CAC7E,IACAkL,EADAJ,EAAA9K,GACA+K,MAAA,KAEA,OAAAG,EAAA5N,OACA,UAAAmC,MAAA,2BAMA,IAHA,IAAAJ,EAAA6L,EAAA,GACA7K,EAAA6K,EAAA3L,MAAA,GAEA6E,EAAA,EAAA+G,EAAA9K,EAAyC+D,EAAA+G,EAAA7N,OAAuB8G,IAGhE,OAFA+G,EAAA/G,GAEA9G,OACA,UAAAmC,MAAA,2BAIAM,EAAAmF,KAAA,CACA7F,OACAgB,YAIA,OAAAN,ECk0Be2J,CAA6BzM,GACvC,MAAAmO,GACL,OAAA7F,KAAAkB,MAAwBzL,EAASqQ,wBAAArE,GAGjC,OACAT,IAAA,CACAlL,KAAcH,EAAaQ,OAC3BqE,SACAiH,WACA6C,cAAAtE,KAAAM,qBAAmD/F,EAAmBC,GAAA,IAEtEuG,IAAA,OAeAjB,EAAApD,UAAAqI,8BAAA,SAAAtE,EAAAC,EAAAqF,EAAAC,GAWA,IAVA,IAAAnH,EAEAoH,GAAA,EACAnL,EAAA,GACAoL,EAAA,IAAAC,IACAC,EAAAJ,EAAA5O,MACAiP,EAAAL,EAAAvE,WAIA,CACA,OAAA2E,EAAArO,OAAA,CACA,IAAA2J,EAAA1B,KAAAoB,gBAEA,cAAAV,IAAAV,KAAA8B,OAAA,KAWA,MATA,IAAAnK,EAAAqI,KAAA4E,uBAAmDnP,EAAS6Q,gCAAkC7Q,EAAS8Q,kCAEvG,GAAA5O,EAAAoJ,IACA,OAAApJ,EAGA0O,EAAAhK,EAAAqF,EAAA1B,KAAAoB,iBACAgF,EAAApG,KAAAD,QAAA/F,MAAA0H,EAAAzB,OAAAD,KAAAC,UAOA,GAAAiG,EAAAM,IAAAJ,GACA,OAAApG,KAAAkB,MAAA,WAAAR,EAAuDjL,EAASgR,mCAAsChR,EAASiR,mCAAAL,GAG/G,UAAAD,IACAH,GAAA,GAMAjG,KAAA6B,YACA,IAAAiB,EAAA9C,KAAAoB,gBAEA,IAAApB,KAAA8B,OAAA,KACA,OAAA9B,KAAAkB,MAAA,WAAAR,EAAuDjL,EAASkR,yCAA4ClR,EAASmR,yCAAAvK,EAAA2D,KAAAoB,gBAAApB,KAAAoB,kBAGrH,IAAAyF,EAAA7G,KAAAQ,aAAAC,EAAA,EAAAC,EAAAqF,GAEA,GAAAc,EAAA9F,IACA,OAAA8F,EAGA,IAAA7C,EAAAhE,KAAAiE,sBAAAnB,GAEA,GAAAkB,EAAAjD,IACA,OAAAiD,EAGAlJ,EAAA6E,KAAA,CAAAyG,EAAA,CACAhP,MAAAyP,EAAA7F,IACAS,SAAApF,EAAAyG,EAAA9C,KAAAoB,oBAGA8E,EAAAY,IAAAV,GAEApG,KAAA6B,YACAuE,GAAAvH,EAAAmB,KAAAiD,6BAAA7L,MAAAiP,EAAAxH,EAAA4C,SAGA,WAAA3G,EAAA/C,OACAiI,KAAAkB,MAAA,WAAAR,EAAqDjL,EAASsR,gCAAmCtR,EAAS6Q,gCAAAjK,EAAA2D,KAAAoB,gBAAApB,KAAAoB,kBAG1GpB,KAAAK,sBAAA4F,EACAjG,KAAAkB,MAAwBzL,EAASuR,qBAAA3K,EAAA2D,KAAAoB,gBAAApB,KAAAoB,kBAGjC,CACAJ,IAAAlG,EACAiG,IAAA,OAIAjB,EAAApD,UAAAkI,uBAAA,SAAAqC,EAAAC,GACA,IAAAC,EAAA,EACA/D,EAAApD,KAAAoB,gBAEApB,KAAA8B,OAAA,MAA4B9B,KAAA8B,OAAA,OAC5BqF,GAAA,GAMA,IAHA,IAAAC,GAAA,EACAC,EAAA,GAEArH,KAAAY,SAAA,CACA,IAAAiC,EAAA7C,KAAAa,OAEA,KAAAgC,GAAA,IAEAA,GAAA,IAOA,MAJAuE,GAAA,EACAC,EAAA,GAAAA,GAAAxE,EAAA,IACA7C,KAAAwB,OAMA,IAAAC,EAAApF,EAAA+G,EAAApD,KAAAoB,iBAEA,OAAAgG,EAMA9J,EAFA+J,GAAAF,GAMA,CACAnG,IAAAqG,EACAtG,IAAA,MALAf,KAAAkB,MAAAgG,EAAAzF,GANAzB,KAAAkB,MAAA+F,EAAAxF,IAeA3B,EAAApD,UAAAuD,OAAA,WACA,OAAAD,KAAA7B,SAAA8B,QAGAH,EAAApD,UAAAkE,MAAA,WACA,OAAAZ,KAAAC,WAAAD,KAAAD,QAAAhI,QAGA+H,EAAApD,UAAA0E,cAAA,WAEA,OACAnB,OAAAD,KAAA7B,SAAA8B,OACAC,KAAAF,KAAA7B,SAAA+B,KACAC,OAAAH,KAAA7B,SAAAgC,SASAL,EAAApD,UAAAmE,KAAA,WACA,IAAAZ,EAAAD,KAAA7B,SAAA8B,OAEA,GAAAA,GAAAD,KAAAD,QAAAhI,OACA,MAAAmC,MAAA,gBAGA,IAAAoE,EAAArB,EAAA+C,KAAAD,QAAAE,GAEA,QAAAT,IAAAlB,EACA,MAAApE,MAAA,UAAAgC,OAAA+D,EAAA,6CAGA,OAAA3B,GAGAwB,EAAApD,UAAAwE,MAAA,SAAAoG,EAAA7F,GACA,OACAT,IAAA,KACAD,IAAA,CACAuG,OACAvH,QAAAC,KAAAD,QACA0B,cAOA3B,EAAApD,UAAA8E,KAAA,WACA,IAAAxB,KAAAY,QAAA,CAIA,IAAAtC,EAAA0B,KAAAa,OAEA,KAAAvC,GAGA0B,KAAA7B,SAAA+B,MAAA,EACAF,KAAA7B,SAAAgC,OAAA,EACAH,KAAA7B,SAAA8B,QAAA,IAEAD,KAAA7B,SAAAgC,QAAA,EAEAH,KAAA7B,SAAA8B,QAAA3B,EAAA,aAWAwB,EAAApD,UAAAoF,OAAA,SAAAyF,GACA,GAAA5K,EAAAqD,KAAAD,QAAAwH,EAAAvH,KAAAC,UAAA,CACA,QAAAzB,EAAA,EAAqBA,EAAA+I,EAAAxP,OAAmByG,IACxCwB,KAAAwB,OAGA,SAGA,UAQA1B,EAAApD,UAAA2I,UAAA,SAAAhB,GACA,IAAAmD,EAAAxH,KAAAC,SACAjB,EAAAgB,KAAAD,QAAA0H,QAAApD,EAAAmD,GAEA,OAAAxI,GAAA,GACAgB,KAAAsD,OAAAtE,IACA,IAEAgB,KAAAsD,OAAAtD,KAAAD,QAAAhI,SACA,IASA+H,EAAApD,UAAA4G,OAAA,SAAAoE,GACA,GAAA1H,KAAAC,SAAAyH,EACA,MAAAxN,MAAA,gBAAAgC,OAAAwL,EAAA,yDAAAxL,OAAA8D,KAAAC,WAKA,IAFAyH,EAAAhK,KAAAiK,IAAAD,EAAA1H,KAAAD,QAAAhI,UAEA,CACA,IAAAkI,EAAAD,KAAAC,SAEA,GAAAA,IAAAyH,EACA,MAGA,GAAAzH,EAAAyH,EACA,MAAAxN,MAAA,gBAAAgC,OAAAwL,EAAA,6CAKA,GAFA1H,KAAAwB,OAEAxB,KAAAY,QACA,QAOAd,EAAApD,UAAAmF,UAAA,WACA,MAAA7B,KAAAY,SAAAnB,GAAAO,KAAAa,SACAb,KAAAwB,QASA1B,EAAApD,UAAAuE,KAAA,WACA,GAAAjB,KAAAY,QACA,YAGA,IAAAtC,EAAA0B,KAAAa,OACAZ,EAAAD,KAAAC,SACA2H,EAAA5H,KAAAD,QAAAZ,WAAAc,GAAA3B,GAAA,YACA,cAAAsJ,QAAA,IAAAA,IAAA,MAGA9H,EA3gCA,GAqhCA,SAAAuB,GAAAuB,GACA,OAAAA,GAAA,IAAAA,GAAA,KAAAA,GAAA,IAAAA,GAAA,GA+BA,SAAAnD,GAAAF,GACA,OAAAA,GAAA,GAAAA,GAAA,SAAAA,GAAA,MAAAA,MAAA,MAAAA,GAAA,aAAAA,GAAA,OAAAA,EAQA,SAAAG,GAAAH,GACA,OAAAA,GAAA,IAAAA,GAAA,SAAAA,MAAA,IAAAA,GAAA,SAAAA,GAAA,KAAAA,GAAA,KAAAA,GAAA,KAAAA,GAAA,KAAAA,GAAA,KAAAA,MAAA,IAAAA,GAAA,IAAAA,GAAA,IAAAA,GAAA,IAAAA,GAAA,IAAAA,GAAA,IAAAA,GAAA,IAAAA,GAAA,SAAAA,GAAA,KAAAA,GAAA,KAAAA,GAAA,KAAAA,GAAA,KAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,MAAA,KAAAA,GAAA,WAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,MAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,aAAAA,GAAA,OAAAA,GAAA,OAAAA,MAAA,MAAAA,GAAA,aAAAA,GAAA,OAAAA,GAAA,OAAAA,MAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,aAAAA,GAAA,OAAAA,MAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,aAAAA,GAAA,OAAAA,GAAA,OAAAA,MAAA,MAAAA,GAAA,aAAAA,GAAA,OAAAA,MAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,aAAAA,MAAA,MAAAA,GAAA,aAAAA,MAAA,MAAAA,GAAA,aAAAA,MAAA,MAAAA,GAAA,aAAAA,MAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,aAAAA,GAAA,OAAAA,GAAA,OAAAA,MAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,aAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,MAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,YAAAA,GAAA,OAAAA,MAAA,MAAAA,GAAA,aAAAA,MAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,aAAAA,MAAA,MAAAA,GAAA,aAAAA,MAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,MAAAA,GAAA,aAAAA,MAAA,MAAAA,GAAA,eAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,eAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,eAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,eAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,eAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,eAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,eAAAA,MAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,eAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,eAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,eAAAA,MAAA,OAAAA,GAAA,eAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,eAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,eAAAA,MAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,eAAAA,GAAA,QAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,eAAAA,MAAA,OAAAA,GAAA,OAAAA,GAAA,OAAAA,GAAA,eAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,eAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,eAAAA,GAAA,QAAAA,GAAA,QAAAA,GAAA,QAAAA,MAAA,OAAAA,GAAA,MCrsCO,SAAAgB,GAAAR,EAAA8H,QACP,IAAAA,IACAA,EAAA,IAGAA,EAAS1M,OAAAC,EAAA,SAAAD,CAAQ,CACjBmF,sBAAA,EACAD,qBAAA,GACGwH,GACH,IAAAlQ,EAAA,IAAmBkI,GAAME,EAAA8H,GAAAtH,QAEzB,GAAA5I,EAAAoJ,IAAA,CACA,IAAAG,EAAA4G,YAA4BrS,EAASkC,EAAAoJ,IAAAuG,OAKrC,MAHApG,EAAAO,SAAA9J,EAAAoJ,IAAAU,SAEAP,EAAA6G,gBAAApQ,EAAAoJ,IAAAhB,QACAmB,EAOA,OAJA,OAAA2G,QAAA,IAAAA,OAAA,EAAAA,EAAAG,kBAvCA,SAAAC,EAAAC,GACAA,EAAAC,QAAA,SAAAtS,GAGA,UAFAA,EAAA4L,SAEQjL,EAAeX,IAAQa,EAAeb,GAC9C,QAAAiJ,KAAAjJ,EAAAiF,eACAjF,EAAAiF,QAAAgE,GAAA2C,SACAwG,EAAApS,EAAAiF,QAAAgE,GAAA1H,YAEelB,EAAeL,IAAQmB,EAAgBnB,EAAAyB,cACtDzB,EAAAyB,MAAAmK,UACgBrL,EAAaP,IAAQS,EAAaT,KAASoB,EAAkBpB,EAAAyB,cAC7EzB,EAAAyB,MAAAmK,SACe3K,EAAYjB,IAC3BoS,EAAApS,EAAAmM,YA0BAiG,CAAAtQ,EAAAqJ,KAGArJ,EAAAqJ,IAhDAoH,EAAAC,EAAAC,EAAA,0BAAA/H,KAAA6H,EAAAC,EAAAC,EAAA,yBAAA5S,IAAA0S,EAAAC,EAAAC,EAAA,kCAAA3S,IAAAyS,EAAAC,EAAAC,EAAA,qCAAA1S,IAAAwS,EAAAC,EAAAC,EAAA,sCAAAtS,IAAAoS,EAAAC,EAAAC,EAAA,oCAAApS,IAAAkS,EAAAC,EAAAC,EAAA,kCAAAlS,IAAAgS,EAAAC,EAAAC,EAAA,kCAAAhS,IAAA8R,EAAAC,EAAAC,EAAA,oCAAA9R,IAAA4R,EAAAC,EAAAC,EAAA,oCAAA5R,IAAA0R,EAAAC,EAAAC,EAAA,mCAAA1R,IAAAwR,EAAAC,EAAAC,EAAA,iCAAAxR,IAAAsR,EAAAC,EAAAC,EAAA,qCAAAtR,IAAAoR,EAAAC,EAAAC,EAAA,uCAAArR,IAAAmR,EAAAC,EAAAC,EAAA,yCAAAnR,IAAAiR,EAAAC,EAAAC,EAAA,wCAAAjR,uCCEA8D,OAAAoN,eAAAC,EAAA,cACApR,OAAA,IAEAoR,EAAAC,aAAAD,EAAAE,aAAAF,EAAAG,aAAAH,EAAAI,aAAAJ,EAAAK,kBAAA,EAEA,IAAAC,EAAcV,EAAQ,IAEtBW,EAAiCX,EAAQ,MAiBzCI,EAAAK,aAfA,SAAAG,GACA,IAAAC,EAAA,kBAAAD,GAAA,EAAAD,EAAAxI,OAAAyI,KACAE,EAAAD,EAAAE,MAEA,OAAAD,IAAA,EAAAH,EAAAnT,kBAAAsT,IACAA,EAAA9R,OAAA,6BACA,EAAA0R,EAAAM,gBAAA,EAAAN,EAAAM,eAAA,GAAAH,GAAA,IAAAC,IAAA,KAGA,EAAAJ,EAAAM,gBAAA,EAAAN,EAAAM,eAAA,GAAAH,GAAA,KACAnT,KAAAiT,EAAArT,KAAAK,QACAqB,MAAA,+BACG,IAsBHoR,EAAAI,aAjBA,SAAAA,EAAAI,GACA,IAAAC,EAAA,kBAAAD,GAAA,EAAAD,EAAAxI,OAAAyI,KAaA,OAZAC,EAAAd,QAAA,SAAAtS,GACA,MAAAkT,EAAAnT,kBAAAC,GACAA,EAAAuB,MAAAvB,EAAAuB,MAAAiS,mBACK,MAAAN,EAAArS,iBAAAb,KAAA,EAAAkT,EAAAvS,iBAAAX,GACL,QAAA4E,EAAA,EAAAoE,EAAA1D,OAAAmO,OAAAzT,EAAAiF,SAAsDL,EAAAoE,EAAA9G,OAAgB0C,IAEtEmO,EADA/J,EAAApE,GACArD,YAEK,EAAA2R,EAAAjS,cAAAjB,IACL+S,EAAA/S,EAAAmM,YAGAiH,GAoBAT,EAAAG,aAfA,SAAAK,GACA,IAAAC,EAAA,kBAAAD,GAAA,EAAAD,EAAAxI,OAAAyI,KACAO,EAAAN,EAAAO,QAEA,OAAAD,IAAA,EAAAR,EAAAnT,kBAAA2T,IACAA,EAAAnS,MAAA,eAAAmS,EAAAnS,OACA,EAAA0R,EAAAM,eAAA,CAAAG,GAAAN,GAAA,KAGA,EAAAH,EAAAM,eAAA,EACAtT,KAAAiT,EAAArT,KAAAK,QACAqB,MAAA,iBACG6R,GAAA,IAIH,IAAAQ,EAAA,uDACAC,EAAA,mTA2BAlB,EAAAE,aAzBA,SAAAA,EAAAM,GACA,IAAAC,EAAA,kBAAAD,GAAA,EAAAD,EAAAxI,OAAAyI,KAqBA,OApBAC,EAAAd,QAAA,SAAAtS,GACA,MAAAkT,EAAAnT,kBAAAC,GACAA,EAAAuB,MAAAvB,EAAAuB,MAAAoO,MAAA,IAAAmE,IAAA,SAAApK,GACA,IAAAf,EAAAiL,EAAAhC,QAAAlI,GAEA,OAAAf,EAAA,EACAe,EAGAmK,EAAAlL,KACOoL,KAAA,SACF,MAAAb,EAAArS,iBAAAb,KAAA,EAAAkT,EAAAvS,iBAAAX,GACL,QAAA4E,EAAA,EAAAoE,EAAA1D,OAAAmO,OAAAzT,EAAAiF,SAAsDL,EAAAoE,EAAA9G,OAAgB0C,IAEtEiO,EADA7J,EAAApE,GACArD,YAEK,EAAA2R,EAAAjS,cAAAjB,IACL6S,EAAA7S,EAAAmM,YAGAiH,GAgCAT,EAAAC,aA3BA,SAAAA,EAAAO,GACA,IAAAC,EAAA,kBAAAD,GAAA,EAAAD,EAAAxI,OAAAyI,KAuBA,OAtBAC,EAAAd,QAAA,SAAAtS,GACA,MAAAkT,EAAAnT,kBAAAC,GAAA,CACA,IAAAgU,EAAAhU,EAAAuB,MAAAoO,MAAA,IAAAmE,IAAA,SAAApK,EAAAP,GACA,IAAAR,EAAAiL,EAAAhC,QAAAlI,GAGA,OAAAf,EAAA,EACAe,GAHAP,EAAA,SAMA0K,EAAAlL,GAAAsL,OAAA,GAAAJ,EAAAlL,KACOoL,KAAA,IACP/T,EAAAuB,MAAA,OAAA8E,OAAA2N,EAAA,aACK,MAAAd,EAAArS,iBAAAb,KAAA,EAAAkT,EAAAvS,iBAAAX,GACL,QAAA4E,EAAA,EAAAoE,EAAA1D,OAAAmO,OAAAzT,EAAAiF,SAAsDL,EAAAoE,EAAA9G,OAAgB0C,IAEtEgO,EADA5J,EAAApE,GACArD,YAEK,EAAA2R,EAAAjS,cAAAjB,IACL4S,EAAA5S,EAAAmM,YAGAiH","file":"static/js/4.b545506b.chunk.js","sourcesContent":["export var ErrorKind;\n\n(function (ErrorKind) {\n  /** Argument is unclosed (e.g. `{0`) */\n  ErrorKind[ErrorKind[\"EXPECT_ARGUMENT_CLOSING_BRACE\"] = 1] = \"EXPECT_ARGUMENT_CLOSING_BRACE\";\n  /** Argument is empty (e.g. `{}`). */\n\n  ErrorKind[ErrorKind[\"EMPTY_ARGUMENT\"] = 2] = \"EMPTY_ARGUMENT\";\n  /** Argument is malformed (e.g. `{foo!}``) */\n\n  ErrorKind[ErrorKind[\"MALFORMED_ARGUMENT\"] = 3] = \"MALFORMED_ARGUMENT\";\n  /** Expect an argument type (e.g. `{foo,}`) */\n\n  ErrorKind[ErrorKind[\"EXPECT_ARGUMENT_TYPE\"] = 4] = \"EXPECT_ARGUMENT_TYPE\";\n  /** Unsupported argument type (e.g. `{foo,foo}`) */\n\n  ErrorKind[ErrorKind[\"INVALID_ARGUMENT_TYPE\"] = 5] = \"INVALID_ARGUMENT_TYPE\";\n  /** Expect an argument style (e.g. `{foo, number, }`) */\n\n  ErrorKind[ErrorKind[\"EXPECT_ARGUMENT_STYLE\"] = 6] = \"EXPECT_ARGUMENT_STYLE\";\n  /** The number skeleton is invalid. */\n\n  ErrorKind[ErrorKind[\"INVALID_NUMBER_SKELETON\"] = 7] = \"INVALID_NUMBER_SKELETON\";\n  /** The date time skeleton is invalid. */\n\n  ErrorKind[ErrorKind[\"INVALID_DATE_TIME_SKELETON\"] = 8] = \"INVALID_DATE_TIME_SKELETON\";\n  /** Exepct a number skeleton following the `::` (e.g. `{foo, number, ::}`) */\n\n  ErrorKind[ErrorKind[\"EXPECT_NUMBER_SKELETON\"] = 9] = \"EXPECT_NUMBER_SKELETON\";\n  /** Exepct a date time skeleton following the `::` (e.g. `{foo, date, ::}`) */\n\n  ErrorKind[ErrorKind[\"EXPECT_DATE_TIME_SKELETON\"] = 10] = \"EXPECT_DATE_TIME_SKELETON\";\n  /** Unmatched apostrophes in the argument style (e.g. `{foo, number, 'test`) */\n\n  ErrorKind[ErrorKind[\"UNCLOSED_QUOTE_IN_ARGUMENT_STYLE\"] = 11] = \"UNCLOSED_QUOTE_IN_ARGUMENT_STYLE\";\n  /** Missing select argument options (e.g. `{foo, select}`) */\n\n  ErrorKind[ErrorKind[\"EXPECT_SELECT_ARGUMENT_OPTIONS\"] = 12] = \"EXPECT_SELECT_ARGUMENT_OPTIONS\";\n  /** Expecting an offset value in `plural` or `selectordinal` argument (e.g `{foo, plural, offset}`) */\n\n  ErrorKind[ErrorKind[\"EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE\"] = 13] = \"EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE\";\n  /** Offset value in `plural` or `selectordinal` is invalid (e.g. `{foo, plural, offset: x}`) */\n\n  ErrorKind[ErrorKind[\"INVALID_PLURAL_ARGUMENT_OFFSET_VALUE\"] = 14] = \"INVALID_PLURAL_ARGUMENT_OFFSET_VALUE\";\n  /** Expecting a selector in `select` argument (e.g `{foo, select}`) */\n\n  ErrorKind[ErrorKind[\"EXPECT_SELECT_ARGUMENT_SELECTOR\"] = 15] = \"EXPECT_SELECT_ARGUMENT_SELECTOR\";\n  /** Expecting a selector in `plural` or `selectordinal` argument (e.g `{foo, plural}`) */\n\n  ErrorKind[ErrorKind[\"EXPECT_PLURAL_ARGUMENT_SELECTOR\"] = 16] = \"EXPECT_PLURAL_ARGUMENT_SELECTOR\";\n  /** Expecting a message fragment after the `select` selector (e.g. `{foo, select, apple}`) */\n\n  ErrorKind[ErrorKind[\"EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT\"] = 17] = \"EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT\";\n  /**\n   * Expecting a message fragment after the `plural` or `selectordinal` selector\n   * (e.g. `{foo, plural, one}`)\n   */\n\n  ErrorKind[ErrorKind[\"EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT\"] = 18] = \"EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT\";\n  /** Selector in `plural` or `selectordinal` is malformed (e.g. `{foo, plural, =x {#}}`) */\n\n  ErrorKind[ErrorKind[\"INVALID_PLURAL_ARGUMENT_SELECTOR\"] = 19] = \"INVALID_PLURAL_ARGUMENT_SELECTOR\";\n  /**\n   * Duplicate selectors in `plural` or `selectordinal` argument.\n   * (e.g. {foo, plural, one {#} one {#}})\n   */\n\n  ErrorKind[ErrorKind[\"DUPLICATE_PLURAL_ARGUMENT_SELECTOR\"] = 20] = \"DUPLICATE_PLURAL_ARGUMENT_SELECTOR\";\n  /** Duplicate selectors in `select` argument.\n   * (e.g. {foo, select, apple {apple} apple {apple}})\n   */\n\n  ErrorKind[ErrorKind[\"DUPLICATE_SELECT_ARGUMENT_SELECTOR\"] = 21] = \"DUPLICATE_SELECT_ARGUMENT_SELECTOR\";\n  /** Plural or select argument option must have `other` clause. */\n\n  ErrorKind[ErrorKind[\"MISSING_OTHER_CLAUSE\"] = 22] = \"MISSING_OTHER_CLAUSE\";\n  /** The tag is malformed. (e.g. `<bold!>foo</bold!>) */\n\n  ErrorKind[ErrorKind[\"INVALID_TAG\"] = 23] = \"INVALID_TAG\";\n  /** The tag name is invalid. (e.g. `<123>foo</123>`) */\n\n  ErrorKind[ErrorKind[\"INVALID_TAG_NAME\"] = 25] = \"INVALID_TAG_NAME\";\n  /** The closing tag does not match the opening tag. (e.g. `<bold>foo</italic>`) */\n\n  ErrorKind[ErrorKind[\"UNMATCHED_CLOSING_TAG\"] = 26] = \"UNMATCHED_CLOSING_TAG\";\n  /** The opening tag has unmatched closing tag. (e.g. `<bold>foo`) */\n\n  ErrorKind[ErrorKind[\"UNCLOSED_TAG\"] = 27] = \"UNCLOSED_TAG\";\n})(ErrorKind || (ErrorKind = {}));","export var TYPE;\n\n(function (TYPE) {\n  /**\n   * Raw text\n   */\n  TYPE[TYPE[\"literal\"] = 0] = \"literal\";\n  /**\n   * Variable w/o any format, e.g `var` in `this is a {var}`\n   */\n\n  TYPE[TYPE[\"argument\"] = 1] = \"argument\";\n  /**\n   * Variable w/ number format\n   */\n\n  TYPE[TYPE[\"number\"] = 2] = \"number\";\n  /**\n   * Variable w/ date format\n   */\n\n  TYPE[TYPE[\"date\"] = 3] = \"date\";\n  /**\n   * Variable w/ time format\n   */\n\n  TYPE[TYPE[\"time\"] = 4] = \"time\";\n  /**\n   * Variable w/ select format\n   */\n\n  TYPE[TYPE[\"select\"] = 5] = \"select\";\n  /**\n   * Variable w/ plural format\n   */\n\n  TYPE[TYPE[\"plural\"] = 6] = \"plural\";\n  /**\n   * Only possible within plural argument.\n   * This is the `#` symbol that will be substituted with the count.\n   */\n\n  TYPE[TYPE[\"pound\"] = 7] = \"pound\";\n  /**\n   * XML-like tag\n   */\n\n  TYPE[TYPE[\"tag\"] = 8] = \"tag\";\n})(TYPE || (TYPE = {}));\n\nexport var SKELETON_TYPE;\n\n(function (SKELETON_TYPE) {\n  SKELETON_TYPE[SKELETON_TYPE[\"number\"] = 0] = \"number\";\n  SKELETON_TYPE[SKELETON_TYPE[\"dateTime\"] = 1] = \"dateTime\";\n})(SKELETON_TYPE || (SKELETON_TYPE = {}));\n/**\n * Type Guards\n */\n\n\nexport function isLiteralElement(el) {\n  return el.type === TYPE.literal;\n}\nexport function isArgumentElement(el) {\n  return el.type === TYPE.argument;\n}\nexport function isNumberElement(el) {\n  return el.type === TYPE.number;\n}\nexport function isDateElement(el) {\n  return el.type === TYPE.date;\n}\nexport function isTimeElement(el) {\n  return el.type === TYPE.time;\n}\nexport function isSelectElement(el) {\n  return el.type === TYPE.select;\n}\nexport function isPluralElement(el) {\n  return el.type === TYPE.plural;\n}\nexport function isPoundElement(el) {\n  return el.type === TYPE.pound;\n}\nexport function isTagElement(el) {\n  return el.type === TYPE.tag;\n}\nexport function isNumberSkeleton(el) {\n  return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.number);\n}\nexport function isDateTimeSkeleton(el) {\n  return !!(el && typeof el === 'object' && el.type === SKELETON_TYPE.dateTime);\n}\nexport function createLiteralElement(value) {\n  return {\n    type: TYPE.literal,\n    value: value\n  };\n}\nexport function createNumberElement(value, style) {\n  return {\n    type: TYPE.number,\n    value: value,\n    style: style\n  };\n}","// @generated from regex-gen.ts\nexport var SPACE_SEPARATOR_REGEX = /[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/;\nexport var WHITE_SPACE_REGEX = /[\\t-\\r \\x85\\u200E\\u200F\\u2028\\u2029]/;","/**\n * https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n * Credit: https://github.com/caridy/intl-datetimeformat-pattern/blob/master/index.js\n * with some tweaks\n */\nvar DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;\n/**\n * Parse Date time skeleton into Intl.DateTimeFormatOptions\n * Ref: https://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table\n * @public\n * @param skeleton skeleton string\n */\n\nexport function parseDateTimeSkeleton(skeleton) {\n  var result = {};\n  skeleton.replace(DATE_TIME_REGEX, function (match) {\n    var len = match.length;\n\n    switch (match[0]) {\n      // Era\n      case 'G':\n        result.era = len === 4 ? 'long' : len === 5 ? 'narrow' : 'short';\n        break;\n      // Year\n\n      case 'y':\n        result.year = len === 2 ? '2-digit' : 'numeric';\n        break;\n\n      case 'Y':\n      case 'u':\n      case 'U':\n      case 'r':\n        throw new RangeError('`Y/u/U/r` (year) patterns are not supported, use `y` instead');\n      // Quarter\n\n      case 'q':\n      case 'Q':\n        throw new RangeError('`q/Q` (quarter) patterns are not supported');\n      // Month\n\n      case 'M':\n      case 'L':\n        result.month = ['numeric', '2-digit', 'short', 'long', 'narrow'][len - 1];\n        break;\n      // Week\n\n      case 'w':\n      case 'W':\n        throw new RangeError('`w/W` (week) patterns are not supported');\n\n      case 'd':\n        result.day = ['numeric', '2-digit'][len - 1];\n        break;\n\n      case 'D':\n      case 'F':\n      case 'g':\n        throw new RangeError('`D/F/g` (day) patterns are not supported, use `d` instead');\n      // Weekday\n\n      case 'E':\n        result.weekday = len === 4 ? 'short' : len === 5 ? 'narrow' : 'short';\n        break;\n\n      case 'e':\n        if (len < 4) {\n          throw new RangeError('`e..eee` (weekday) patterns are not supported');\n        }\n\n        result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];\n        break;\n\n      case 'c':\n        if (len < 4) {\n          throw new RangeError('`c..ccc` (weekday) patterns are not supported');\n        }\n\n        result.weekday = ['short', 'long', 'narrow', 'short'][len - 4];\n        break;\n      // Period\n\n      case 'a':\n        // AM, PM\n        result.hour12 = true;\n        break;\n\n      case 'b': // am, pm, noon, midnight\n\n      case 'B':\n        // flexible day periods\n        throw new RangeError('`b/B` (period) patterns are not supported, use `a` instead');\n      // Hour\n\n      case 'h':\n        result.hourCycle = 'h12';\n        result.hour = ['numeric', '2-digit'][len - 1];\n        break;\n\n      case 'H':\n        result.hourCycle = 'h23';\n        result.hour = ['numeric', '2-digit'][len - 1];\n        break;\n\n      case 'K':\n        result.hourCycle = 'h11';\n        result.hour = ['numeric', '2-digit'][len - 1];\n        break;\n\n      case 'k':\n        result.hourCycle = 'h24';\n        result.hour = ['numeric', '2-digit'][len - 1];\n        break;\n\n      case 'j':\n      case 'J':\n      case 'C':\n        throw new RangeError('`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead');\n      // Minute\n\n      case 'm':\n        result.minute = ['numeric', '2-digit'][len - 1];\n        break;\n      // Second\n\n      case 's':\n        result.second = ['numeric', '2-digit'][len - 1];\n        break;\n\n      case 'S':\n      case 'A':\n        throw new RangeError('`S/A` (second) patterns are not supported, use `s` instead');\n      // Zone\n\n      case 'z':\n        // 1..3, 4: specific non-location format\n        result.timeZoneName = len < 4 ? 'short' : 'long';\n        break;\n\n      case 'Z': // 1..3, 4, 5: The ISO8601 varios formats\n\n      case 'O': // 1, 4: miliseconds in day short, long\n\n      case 'v': // 1, 4: generic non-location format\n\n      case 'V': // 1, 2, 3, 4: time zone ID or city\n\n      case 'X': // 1, 2, 3, 4: The ISO8601 varios formats\n\n      case 'x':\n        // 1, 2, 3, 4: The ISO8601 varios formats\n        throw new RangeError('`Z/O/v/V/X/x` (timeZone) patterns are not supported, use `z` instead');\n    }\n\n    return '';\n  });\n  return result;\n}","// @generated from regex-gen.ts\nexport var WHITE_SPACE_REGEX = /[\\t-\\r \\x85\\u200E\\u200F\\u2028\\u2029]/i;","import { __assign } from \"tslib\";\nimport { WHITE_SPACE_REGEX } from './regex.generated';\nexport function parseNumberSkeletonFromString(skeleton) {\n  if (skeleton.length === 0) {\n    throw new Error('Number skeleton cannot be empty');\n  } // Parse the skeleton\n\n\n  var stringTokens = skeleton.split(WHITE_SPACE_REGEX).filter(function (x) {\n    return x.length > 0;\n  });\n  var tokens = [];\n\n  for (var _i = 0, stringTokens_1 = stringTokens; _i < stringTokens_1.length; _i++) {\n    var stringToken = stringTokens_1[_i];\n    var stemAndOptions = stringToken.split('/');\n\n    if (stemAndOptions.length === 0) {\n      throw new Error('Invalid number skeleton');\n    }\n\n    var stem = stemAndOptions[0],\n        options = stemAndOptions.slice(1);\n\n    for (var _a = 0, options_1 = options; _a < options_1.length; _a++) {\n      var option = options_1[_a];\n\n      if (option.length === 0) {\n        throw new Error('Invalid number skeleton');\n      }\n    }\n\n    tokens.push({\n      stem: stem,\n      options: options\n    });\n  }\n\n  return tokens;\n}\n\nfunction icuUnitToEcma(unit) {\n  return unit.replace(/^(.*?)-/, '');\n}\n\nvar FRACTION_PRECISION_REGEX = /^\\.(?:(0+)(\\*)?|(#+)|(0+)(#+))$/g;\nvar SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\\+|#+)?[rs]?$/g;\nvar INTEGER_WIDTH_REGEX = /(\\*)(0+)|(#+)(0+)|(0+)/g;\nvar CONCISE_INTEGER_WIDTH_REGEX = /^(0+)$/;\n\nfunction parseSignificantPrecision(str) {\n  var result = {};\n\n  if (str[str.length - 1] === 'r') {\n    result.roundingPriority = 'morePrecision';\n  } else if (str[str.length - 1] === 's') {\n    result.roundingPriority = 'lessPrecision';\n  }\n\n  str.replace(SIGNIFICANT_PRECISION_REGEX, function (_, g1, g2) {\n    // @@@ case\n    if (typeof g2 !== 'string') {\n      result.minimumSignificantDigits = g1.length;\n      result.maximumSignificantDigits = g1.length;\n    } // @@@+ case\n    else if (g2 === '+') {\n      result.minimumSignificantDigits = g1.length;\n    } // .### case\n    else if (g1[0] === '#') {\n      result.maximumSignificantDigits = g1.length;\n    } // .@@## or .@@@ case\n    else {\n      result.minimumSignificantDigits = g1.length;\n      result.maximumSignificantDigits = g1.length + (typeof g2 === 'string' ? g2.length : 0);\n    }\n\n    return '';\n  });\n  return result;\n}\n\nfunction parseSign(str) {\n  switch (str) {\n    case 'sign-auto':\n      return {\n        signDisplay: 'auto'\n      };\n\n    case 'sign-accounting':\n    case '()':\n      return {\n        currencySign: 'accounting'\n      };\n\n    case 'sign-always':\n    case '+!':\n      return {\n        signDisplay: 'always'\n      };\n\n    case 'sign-accounting-always':\n    case '()!':\n      return {\n        signDisplay: 'always',\n        currencySign: 'accounting'\n      };\n\n    case 'sign-except-zero':\n    case '+?':\n      return {\n        signDisplay: 'exceptZero'\n      };\n\n    case 'sign-accounting-except-zero':\n    case '()?':\n      return {\n        signDisplay: 'exceptZero',\n        currencySign: 'accounting'\n      };\n\n    case 'sign-never':\n    case '+_':\n      return {\n        signDisplay: 'never'\n      };\n  }\n}\n\nfunction parseConciseScientificAndEngineeringStem(stem) {\n  // Engineering\n  var result;\n\n  if (stem[0] === 'E' && stem[1] === 'E') {\n    result = {\n      notation: 'engineering'\n    };\n    stem = stem.slice(2);\n  } else if (stem[0] === 'E') {\n    result = {\n      notation: 'scientific'\n    };\n    stem = stem.slice(1);\n  }\n\n  if (result) {\n    var signDisplay = stem.slice(0, 2);\n\n    if (signDisplay === '+!') {\n      result.signDisplay = 'always';\n      stem = stem.slice(2);\n    } else if (signDisplay === '+?') {\n      result.signDisplay = 'exceptZero';\n      stem = stem.slice(2);\n    }\n\n    if (!CONCISE_INTEGER_WIDTH_REGEX.test(stem)) {\n      throw new Error('Malformed concise eng/scientific notation');\n    }\n\n    result.minimumIntegerDigits = stem.length;\n  }\n\n  return result;\n}\n\nfunction parseNotationOptions(opt) {\n  var result = {};\n  var signOpts = parseSign(opt);\n\n  if (signOpts) {\n    return signOpts;\n  }\n\n  return result;\n}\n/**\n * https://github.com/unicode-org/icu/blob/master/docs/userguide/format_parse/numbers/skeletons.md#skeleton-stems-and-options\n */\n\n\nexport function parseNumberSkeleton(tokens) {\n  var result = {};\n\n  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {\n    var token = tokens_1[_i];\n\n    switch (token.stem) {\n      case 'percent':\n      case '%':\n        result.style = 'percent';\n        continue;\n\n      case '%x100':\n        result.style = 'percent';\n        result.scale = 100;\n        continue;\n\n      case 'currency':\n        result.style = 'currency';\n        result.currency = token.options[0];\n        continue;\n\n      case 'group-off':\n      case ',_':\n        result.useGrouping = false;\n        continue;\n\n      case 'precision-integer':\n      case '.':\n        result.maximumFractionDigits = 0;\n        continue;\n\n      case 'measure-unit':\n      case 'unit':\n        result.style = 'unit';\n        result.unit = icuUnitToEcma(token.options[0]);\n        continue;\n\n      case 'compact-short':\n      case 'K':\n        result.notation = 'compact';\n        result.compactDisplay = 'short';\n        continue;\n\n      case 'compact-long':\n      case 'KK':\n        result.notation = 'compact';\n        result.compactDisplay = 'long';\n        continue;\n\n      case 'scientific':\n        result = __assign(__assign(__assign({}, result), {\n          notation: 'scientific'\n        }), token.options.reduce(function (all, opt) {\n          return __assign(__assign({}, all), parseNotationOptions(opt));\n        }, {}));\n        continue;\n\n      case 'engineering':\n        result = __assign(__assign(__assign({}, result), {\n          notation: 'engineering'\n        }), token.options.reduce(function (all, opt) {\n          return __assign(__assign({}, all), parseNotationOptions(opt));\n        }, {}));\n        continue;\n\n      case 'notation-simple':\n        result.notation = 'standard';\n        continue;\n      // https://github.com/unicode-org/icu/blob/master/icu4c/source/i18n/unicode/unumberformatter.h\n\n      case 'unit-width-narrow':\n        result.currencyDisplay = 'narrowSymbol';\n        result.unitDisplay = 'narrow';\n        continue;\n\n      case 'unit-width-short':\n        result.currencyDisplay = 'code';\n        result.unitDisplay = 'short';\n        continue;\n\n      case 'unit-width-full-name':\n        result.currencyDisplay = 'name';\n        result.unitDisplay = 'long';\n        continue;\n\n      case 'unit-width-iso-code':\n        result.currencyDisplay = 'symbol';\n        continue;\n\n      case 'scale':\n        result.scale = parseFloat(token.options[0]);\n        continue;\n      // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width\n\n      case 'integer-width':\n        if (token.options.length > 1) {\n          throw new RangeError('integer-width stems only accept a single optional option');\n        }\n\n        token.options[0].replace(INTEGER_WIDTH_REGEX, function (_, g1, g2, g3, g4, g5) {\n          if (g1) {\n            result.minimumIntegerDigits = g2.length;\n          } else if (g3 && g4) {\n            throw new Error('We currently do not support maximum integer digits');\n          } else if (g5) {\n            throw new Error('We currently do not support exact integer digits');\n          }\n\n          return '';\n        });\n        continue;\n    } // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#integer-width\n\n\n    if (CONCISE_INTEGER_WIDTH_REGEX.test(token.stem)) {\n      result.minimumIntegerDigits = token.stem.length;\n      continue;\n    }\n\n    if (FRACTION_PRECISION_REGEX.test(token.stem)) {\n      // Precision\n      // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#fraction-precision\n      // precision-integer case\n      if (token.options.length > 1) {\n        throw new RangeError('Fraction-precision stems only accept a single optional option');\n      }\n\n      token.stem.replace(FRACTION_PRECISION_REGEX, function (_, g1, g2, g3, g4, g5) {\n        // .000* case (before ICU67 it was .000+)\n        if (g2 === '*') {\n          result.minimumFractionDigits = g1.length;\n        } // .### case\n        else if (g3 && g3[0] === '#') {\n          result.maximumFractionDigits = g3.length;\n        } // .00## case\n        else if (g4 && g5) {\n          result.minimumFractionDigits = g4.length;\n          result.maximumFractionDigits = g4.length + g5.length;\n        } else {\n          result.minimumFractionDigits = g1.length;\n          result.maximumFractionDigits = g1.length;\n        }\n\n        return '';\n      });\n      var opt = token.options[0]; // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#trailing-zero-display\n\n      if (opt === 'w') {\n        result = __assign(__assign({}, result), {\n          trailingZeroDisplay: 'stripIfInteger'\n        });\n      } else if (opt) {\n        result = __assign(__assign({}, result), parseSignificantPrecision(opt));\n      }\n\n      continue;\n    } // https://unicode-org.github.io/icu/userguide/format_parse/numbers/skeletons.html#significant-digits-precision\n\n\n    if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {\n      result = __assign(__assign({}, result), parseSignificantPrecision(token.stem));\n      continue;\n    }\n\n    var signOpts = parseSign(token.stem);\n\n    if (signOpts) {\n      result = __assign(__assign({}, result), signOpts);\n    }\n\n    var conciseScientificAndEngineeringOpts = parseConciseScientificAndEngineeringStem(token.stem);\n\n    if (conciseScientificAndEngineeringOpts) {\n      result = __assign(__assign({}, result), conciseScientificAndEngineeringOpts);\n    }\n  }\n\n  return result;\n}","var _a;\n\nimport { __assign } from \"tslib\";\nimport { ErrorKind } from './error';\nimport { SKELETON_TYPE, TYPE } from './types';\nimport { SPACE_SEPARATOR_REGEX } from './regex.generated';\nimport { parseNumberSkeleton, parseNumberSkeletonFromString, parseDateTimeSkeleton } from '@formatjs/icu-skeleton-parser';\nvar SPACE_SEPARATOR_START_REGEX = new RegExp(\"^\".concat(SPACE_SEPARATOR_REGEX.source, \"*\"));\nvar SPACE_SEPARATOR_END_REGEX = new RegExp(\"\".concat(SPACE_SEPARATOR_REGEX.source, \"*$\"));\n\nfunction createLocation(start, end) {\n  return {\n    start: start,\n    end: end\n  };\n} // #region Ponyfills\n// Consolidate these variables up top for easier toggling during debugging\n\n\nvar hasNativeStartsWith = !!String.prototype.startsWith;\nvar hasNativeFromCodePoint = !!String.fromCodePoint;\nvar hasNativeFromEntries = !!Object.fromEntries;\nvar hasNativeCodePointAt = !!String.prototype.codePointAt;\nvar hasTrimStart = !!String.prototype.trimStart;\nvar hasTrimEnd = !!String.prototype.trimEnd;\nvar hasNativeIsSafeInteger = !!Number.isSafeInteger;\nvar isSafeInteger = hasNativeIsSafeInteger ? Number.isSafeInteger : function (n) {\n  return typeof n === 'number' && isFinite(n) && Math.floor(n) === n && Math.abs(n) <= 0x1fffffffffffff;\n}; // IE11 does not support y and u.\n\nvar REGEX_SUPPORTS_U_AND_Y = true;\n\ntry {\n  var re = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n  /**\n   * legacy Edge or Xbox One browser\n   * Unicode flag support: supported\n   * Pattern_Syntax support: not supported\n   * See https://github.com/formatjs/formatjs/issues/2822\n   */\n\n  REGEX_SUPPORTS_U_AND_Y = ((_a = re.exec('a')) === null || _a === void 0 ? void 0 : _a[0]) === 'a';\n} catch (_) {\n  REGEX_SUPPORTS_U_AND_Y = false;\n}\n\nvar startsWith = hasNativeStartsWith ? // Native\nfunction startsWith(s, search, position) {\n  return s.startsWith(search, position);\n} : // For IE11\nfunction startsWith(s, search, position) {\n  return s.slice(position, position + search.length) === search;\n};\nvar fromCodePoint = hasNativeFromCodePoint ? String.fromCodePoint : // IE11\nfunction fromCodePoint() {\n  var codePoints = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    codePoints[_i] = arguments[_i];\n  }\n\n  var elements = '';\n  var length = codePoints.length;\n  var i = 0;\n  var code;\n\n  while (length > i) {\n    code = codePoints[i++];\n    if (code > 0x10ffff) throw RangeError(code + ' is not a valid code point');\n    elements += code < 0x10000 ? String.fromCharCode(code) : String.fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00);\n  }\n\n  return elements;\n};\nvar fromEntries = // native\nhasNativeFromEntries ? Object.fromEntries : // Ponyfill\nfunction fromEntries(entries) {\n  var obj = {};\n\n  for (var _i = 0, entries_1 = entries; _i < entries_1.length; _i++) {\n    var _a = entries_1[_i],\n        k = _a[0],\n        v = _a[1];\n    obj[k] = v;\n  }\n\n  return obj;\n};\nvar codePointAt = hasNativeCodePointAt ? // Native\nfunction codePointAt(s, index) {\n  return s.codePointAt(index);\n} : // IE 11\nfunction codePointAt(s, index) {\n  var size = s.length;\n\n  if (index < 0 || index >= size) {\n    return undefined;\n  }\n\n  var first = s.charCodeAt(index);\n  var second;\n  return first < 0xd800 || first > 0xdbff || index + 1 === size || (second = s.charCodeAt(index + 1)) < 0xdc00 || second > 0xdfff ? first : (first - 0xd800 << 10) + (second - 0xdc00) + 0x10000;\n};\nvar trimStart = hasTrimStart ? // Native\nfunction trimStart(s) {\n  return s.trimStart();\n} : // Ponyfill\nfunction trimStart(s) {\n  return s.replace(SPACE_SEPARATOR_START_REGEX, '');\n};\nvar trimEnd = hasTrimEnd ? // Native\nfunction trimEnd(s) {\n  return s.trimEnd();\n} : // Ponyfill\nfunction trimEnd(s) {\n  return s.replace(SPACE_SEPARATOR_END_REGEX, '');\n}; // Prevent minifier to translate new RegExp to literal form that might cause syntax error on IE11.\n\nfunction RE(s, flag) {\n  return new RegExp(s, flag);\n} // #endregion\n\n\nvar matchIdentifierAtIndex;\n\nif (REGEX_SUPPORTS_U_AND_Y) {\n  // Native\n  var IDENTIFIER_PREFIX_RE_1 = RE('([^\\\\p{White_Space}\\\\p{Pattern_Syntax}]*)', 'yu');\n\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var _a;\n\n    IDENTIFIER_PREFIX_RE_1.lastIndex = index;\n    var match = IDENTIFIER_PREFIX_RE_1.exec(s);\n    return (_a = match[1]) !== null && _a !== void 0 ? _a : '';\n  };\n} else {\n  // IE11\n  matchIdentifierAtIndex = function matchIdentifierAtIndex(s, index) {\n    var match = [];\n\n    while (true) {\n      var c = codePointAt(s, index);\n\n      if (c === undefined || _isWhiteSpace(c) || _isPatternSyntax(c)) {\n        break;\n      }\n\n      match.push(c);\n      index += c >= 0x10000 ? 2 : 1;\n    }\n\n    return fromCodePoint.apply(void 0, match);\n  };\n}\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(message, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.message = message;\n    this.position = {\n      offset: 0,\n      line: 1,\n      column: 1\n    };\n    this.ignoreTag = !!options.ignoreTag;\n    this.requiresOtherClause = !!options.requiresOtherClause;\n    this.shouldParseSkeletons = !!options.shouldParseSkeletons;\n  }\n\n  Parser.prototype.parse = function () {\n    if (this.offset() !== 0) {\n      throw Error('parser can only be used once');\n    }\n\n    return this.parseMessage(0, '', false);\n  };\n\n  Parser.prototype.parseMessage = function (nestingLevel, parentArgType, expectingCloseTag) {\n    var elements = [];\n\n    while (!this.isEOF()) {\n      var char = this.char();\n\n      if (char === 123\n      /* `{` */\n      ) {\n        var result = this.parseArgument(nestingLevel, expectingCloseTag);\n\n        if (result.err) {\n          return result;\n        }\n\n        elements.push(result.val);\n      } else if (char === 125\n      /* `}` */\n      && nestingLevel > 0) {\n        break;\n      } else if (char === 35\n      /* `#` */\n      && (parentArgType === 'plural' || parentArgType === 'selectordinal')) {\n        var position = this.clonePosition();\n        this.bump();\n        elements.push({\n          type: TYPE.pound,\n          location: createLocation(position, this.clonePosition())\n        });\n      } else if (char === 60\n      /* `<` */\n      && !this.ignoreTag && this.peek() === 47 // char code for '/'\n      ) {\n        if (expectingCloseTag) {\n          break;\n        } else {\n          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(this.clonePosition(), this.clonePosition()));\n        }\n      } else if (char === 60\n      /* `<` */\n      && !this.ignoreTag && _isAlpha(this.peek() || 0)) {\n        var result = this.parseTag(nestingLevel, parentArgType);\n\n        if (result.err) {\n          return result;\n        }\n\n        elements.push(result.val);\n      } else {\n        var result = this.parseLiteral(nestingLevel, parentArgType);\n\n        if (result.err) {\n          return result;\n        }\n\n        elements.push(result.val);\n      }\n    }\n\n    return {\n      val: elements,\n      err: null\n    };\n  };\n  /**\n   * A tag name must start with an ASCII lower/upper case letter. The grammar is based on the\n   * [custom element name][] except that a dash is NOT always mandatory and uppercase letters\n   * are accepted:\n   *\n   * ```\n   * tag ::= \"<\" tagName (whitespace)* \"/>\" | \"<\" tagName (whitespace)* \">\" message \"</\" tagName (whitespace)* \">\"\n   * tagName ::= [a-z] (PENChar)*\n   * PENChar ::=\n   *     \"-\" | \".\" | [0-9] | \"_\" | [a-z] | [A-Z] | #xB7 | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x37D] |\n   *     [#x37F-#x1FFF] | [#x200C-#x200D] | [#x203F-#x2040] | [#x2070-#x218F] | [#x2C00-#x2FEF] |\n   *     [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\n   * ```\n   *\n   * [custom element name]: https://html.spec.whatwg.org/multipage/custom-elements.html#valid-custom-element-name\n   * NOTE: We're a bit more lax here since HTML technically does not allow uppercase HTML element but we do\n   * since other tag-based engines like React allow it\n   */\n\n\n  Parser.prototype.parseTag = function (nestingLevel, parentArgType) {\n    var startPosition = this.clonePosition();\n    this.bump(); // `<`\n\n    var tagName = this.parseTagName();\n    this.bumpSpace();\n\n    if (this.bumpIf('/>')) {\n      // Self closing tag\n      return {\n        val: {\n          type: TYPE.literal,\n          value: \"<\".concat(tagName, \"/>\"),\n          location: createLocation(startPosition, this.clonePosition())\n        },\n        err: null\n      };\n    } else if (this.bumpIf('>')) {\n      var childrenResult = this.parseMessage(nestingLevel + 1, parentArgType, true);\n\n      if (childrenResult.err) {\n        return childrenResult;\n      }\n\n      var children = childrenResult.val; // Expecting a close tag\n\n      var endTagStartPosition = this.clonePosition();\n\n      if (this.bumpIf('</')) {\n        if (this.isEOF() || !_isAlpha(this.char())) {\n          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n\n        var closingTagNameStartPosition = this.clonePosition();\n        var closingTagName = this.parseTagName();\n\n        if (tagName !== closingTagName) {\n          return this.error(ErrorKind.UNMATCHED_CLOSING_TAG, createLocation(closingTagNameStartPosition, this.clonePosition()));\n        }\n\n        this.bumpSpace();\n\n        if (!this.bumpIf('>')) {\n          return this.error(ErrorKind.INVALID_TAG, createLocation(endTagStartPosition, this.clonePosition()));\n        }\n\n        return {\n          val: {\n            type: TYPE.tag,\n            value: tagName,\n            children: children,\n            location: createLocation(startPosition, this.clonePosition())\n          },\n          err: null\n        };\n      } else {\n        return this.error(ErrorKind.UNCLOSED_TAG, createLocation(startPosition, this.clonePosition()));\n      }\n    } else {\n      return this.error(ErrorKind.INVALID_TAG, createLocation(startPosition, this.clonePosition()));\n    }\n  };\n  /**\n   * This method assumes that the caller has peeked ahead for the first tag character.\n   */\n\n\n  Parser.prototype.parseTagName = function () {\n    var startOffset = this.offset();\n    this.bump(); // the first tag name character\n\n    while (!this.isEOF() && _isPotentialElementNameChar(this.char())) {\n      this.bump();\n    }\n\n    return this.message.slice(startOffset, this.offset());\n  };\n\n  Parser.prototype.parseLiteral = function (nestingLevel, parentArgType) {\n    var start = this.clonePosition();\n    var value = '';\n\n    while (true) {\n      var parseQuoteResult = this.tryParseQuote(parentArgType);\n\n      if (parseQuoteResult) {\n        value += parseQuoteResult;\n        continue;\n      }\n\n      var parseUnquotedResult = this.tryParseUnquoted(nestingLevel, parentArgType);\n\n      if (parseUnquotedResult) {\n        value += parseUnquotedResult;\n        continue;\n      }\n\n      var parseLeftAngleResult = this.tryParseLeftAngleBracket();\n\n      if (parseLeftAngleResult) {\n        value += parseLeftAngleResult;\n        continue;\n      }\n\n      break;\n    }\n\n    var location = createLocation(start, this.clonePosition());\n    return {\n      val: {\n        type: TYPE.literal,\n        value: value,\n        location: location\n      },\n      err: null\n    };\n  };\n\n  Parser.prototype.tryParseLeftAngleBracket = function () {\n    if (!this.isEOF() && this.char() === 60\n    /* `<` */\n    && (this.ignoreTag || // If at the opening tag or closing tag position, bail.\n    !_isAlphaOrSlash(this.peek() || 0))) {\n      this.bump(); // `<`\n\n      return '<';\n    }\n\n    return null;\n  };\n  /**\n   * Starting with ICU 4.8, an ASCII apostrophe only starts quoted text if it immediately precedes\n   * a character that requires quoting (that is, \"only where needed\"), and works the same in\n   * nested messages as on the top level of the pattern. The new behavior is otherwise compatible.\n   */\n\n\n  Parser.prototype.tryParseQuote = function (parentArgType) {\n    if (this.isEOF() || this.char() !== 39\n    /* `'` */\n    ) {\n      return null;\n    } // Parse escaped char following the apostrophe, or early return if there is no escaped char.\n    // Check if is valid escaped character\n\n\n    switch (this.peek()) {\n      case 39\n      /* `'` */\n      :\n        // double quote, should return as a single quote.\n        this.bump();\n        this.bump();\n        return \"'\";\n      // '{', '<', '>', '}'\n\n      case 123:\n      case 60:\n      case 62:\n      case 125:\n        break;\n\n      case 35:\n        // '#'\n        if (parentArgType === 'plural' || parentArgType === 'selectordinal') {\n          break;\n        }\n\n        return null;\n\n      default:\n        return null;\n    }\n\n    this.bump(); // apostrophe\n\n    var codePoints = [this.char()]; // escaped char\n\n    this.bump(); // read chars until the optional closing apostrophe is found\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      if (ch === 39\n      /* `'` */\n      ) {\n        if (this.peek() === 39\n        /* `'` */\n        ) {\n          codePoints.push(39); // Bump one more time because we need to skip 2 characters.\n\n          this.bump();\n        } else {\n          // Optional closing apostrophe.\n          this.bump();\n          break;\n        }\n      } else {\n        codePoints.push(ch);\n      }\n\n      this.bump();\n    }\n\n    return fromCodePoint.apply(void 0, codePoints);\n  };\n\n  Parser.prototype.tryParseUnquoted = function (nestingLevel, parentArgType) {\n    if (this.isEOF()) {\n      return null;\n    }\n\n    var ch = this.char();\n\n    if (ch === 60\n    /* `<` */\n    || ch === 123\n    /* `{` */\n    || ch === 35\n    /* `#` */\n    && (parentArgType === 'plural' || parentArgType === 'selectordinal') || ch === 125\n    /* `}` */\n    && nestingLevel > 0) {\n      return null;\n    } else {\n      this.bump();\n      return fromCodePoint(ch);\n    }\n  };\n\n  Parser.prototype.parseArgument = function (nestingLevel, expectingCloseTag) {\n    var openingBracePosition = this.clonePosition();\n    this.bump(); // `{`\n\n    this.bumpSpace();\n\n    if (this.isEOF()) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    if (this.char() === 125\n    /* `}` */\n    ) {\n      this.bump();\n      return this.error(ErrorKind.EMPTY_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    } // argument name\n\n\n    var value = this.parseIdentifierIfPossible().value;\n\n    if (!value) {\n      return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    this.bumpSpace();\n\n    if (this.isEOF()) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    switch (this.char()) {\n      // Simple argument: `{name}`\n      case 125\n      /* `}` */\n      :\n        {\n          this.bump(); // `}`\n\n          return {\n            val: {\n              type: TYPE.argument,\n              // value does not include the opening and closing braces.\n              value: value,\n              location: createLocation(openingBracePosition, this.clonePosition())\n            },\n            err: null\n          };\n        }\n      // Argument with options: `{name, format, ...}`\n\n      case 44\n      /* `,` */\n      :\n        {\n          this.bump(); // `,`\n\n          this.bumpSpace();\n\n          if (this.isEOF()) {\n            return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n          }\n\n          return this.parseArgumentOptions(nestingLevel, expectingCloseTag, value, openingBracePosition);\n        }\n\n      default:\n        return this.error(ErrorKind.MALFORMED_ARGUMENT, createLocation(openingBracePosition, this.clonePosition()));\n    }\n  };\n  /**\n   * Advance the parser until the end of the identifier, if it is currently on\n   * an identifier character. Return an empty string otherwise.\n   */\n\n\n  Parser.prototype.parseIdentifierIfPossible = function () {\n    var startingPosition = this.clonePosition();\n    var startOffset = this.offset();\n    var value = matchIdentifierAtIndex(this.message, startOffset);\n    var endOffset = startOffset + value.length;\n    this.bumpTo(endOffset);\n    var endPosition = this.clonePosition();\n    var location = createLocation(startingPosition, endPosition);\n    return {\n      value: value,\n      location: location\n    };\n  };\n\n  Parser.prototype.parseArgumentOptions = function (nestingLevel, expectingCloseTag, value, openingBracePosition) {\n    var _a; // Parse this range:\n    // {name, type, style}\n    //        ^---^\n\n\n    var typeStartPosition = this.clonePosition();\n    var argType = this.parseIdentifierIfPossible().value;\n    var typeEndPosition = this.clonePosition();\n\n    switch (argType) {\n      case '':\n        // Expecting a style string number, date, time, plural, selectordinal, or select.\n        return this.error(ErrorKind.EXPECT_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n\n      case 'number':\n      case 'date':\n      case 'time':\n        {\n          // Parse this range:\n          // {name, number, style}\n          //              ^-------^\n          this.bumpSpace();\n          var styleAndLocation = null;\n\n          if (this.bumpIf(',')) {\n            this.bumpSpace();\n            var styleStartPosition = this.clonePosition();\n            var result = this.parseSimpleArgStyleIfPossible();\n\n            if (result.err) {\n              return result;\n            }\n\n            var style = trimEnd(result.val);\n\n            if (style.length === 0) {\n              return this.error(ErrorKind.EXPECT_ARGUMENT_STYLE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n\n            var styleLocation = createLocation(styleStartPosition, this.clonePosition());\n            styleAndLocation = {\n              style: style,\n              styleLocation: styleLocation\n            };\n          }\n\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n\n          var location_1 = createLocation(openingBracePosition, this.clonePosition()); // Extract style or skeleton\n\n          if (styleAndLocation && startsWith(styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style, '::', 0)) {\n            // Skeleton starts with `::`.\n            var skeleton = trimStart(styleAndLocation.style.slice(2));\n\n            if (argType === 'number') {\n              var result = this.parseNumberSkeletonFromString(skeleton, styleAndLocation.styleLocation);\n\n              if (result.err) {\n                return result;\n              }\n\n              return {\n                val: {\n                  type: TYPE.number,\n                  value: value,\n                  location: location_1,\n                  style: result.val\n                },\n                err: null\n              };\n            } else {\n              if (skeleton.length === 0) {\n                return this.error(ErrorKind.EXPECT_DATE_TIME_SKELETON, location_1);\n              }\n\n              var style = {\n                type: SKELETON_TYPE.dateTime,\n                pattern: skeleton,\n                location: styleAndLocation.styleLocation,\n                parsedOptions: this.shouldParseSkeletons ? parseDateTimeSkeleton(skeleton) : {}\n              };\n              var type = argType === 'date' ? TYPE.date : TYPE.time;\n              return {\n                val: {\n                  type: type,\n                  value: value,\n                  location: location_1,\n                  style: style\n                },\n                err: null\n              };\n            }\n          } // Regular style or no style.\n\n\n          return {\n            val: {\n              type: argType === 'number' ? TYPE.number : argType === 'date' ? TYPE.date : TYPE.time,\n              value: value,\n              location: location_1,\n              style: (_a = styleAndLocation === null || styleAndLocation === void 0 ? void 0 : styleAndLocation.style) !== null && _a !== void 0 ? _a : null\n            },\n            err: null\n          };\n        }\n\n      case 'plural':\n      case 'selectordinal':\n      case 'select':\n        {\n          // Parse this range:\n          // {name, plural, options}\n          //              ^---------^\n          var typeEndPosition_1 = this.clonePosition();\n          this.bumpSpace();\n\n          if (!this.bumpIf(',')) {\n            return this.error(ErrorKind.EXPECT_SELECT_ARGUMENT_OPTIONS, createLocation(typeEndPosition_1, __assign({}, typeEndPosition_1)));\n          }\n\n          this.bumpSpace(); // Parse offset:\n          // {name, plural, offset:1, options}\n          //                ^-----^\n          //\n          // or the first option:\n          //\n          // {name, plural, one {...} other {...}}\n          //                ^--^\n\n          var identifierAndLocation = this.parseIdentifierIfPossible();\n          var pluralOffset = 0;\n\n          if (argType !== 'select' && identifierAndLocation.value === 'offset') {\n            if (!this.bumpIf(':')) {\n              return this.error(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, createLocation(this.clonePosition(), this.clonePosition()));\n            }\n\n            this.bumpSpace();\n            var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_OFFSET_VALUE, ErrorKind.INVALID_PLURAL_ARGUMENT_OFFSET_VALUE);\n\n            if (result.err) {\n              return result;\n            } // Parse another identifier for option parsing\n\n\n            this.bumpSpace();\n            identifierAndLocation = this.parseIdentifierIfPossible();\n            pluralOffset = result.val;\n          }\n\n          var optionsResult = this.tryParsePluralOrSelectOptions(nestingLevel, argType, expectingCloseTag, identifierAndLocation);\n\n          if (optionsResult.err) {\n            return optionsResult;\n          }\n\n          var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n          if (argCloseResult.err) {\n            return argCloseResult;\n          }\n\n          var location_2 = createLocation(openingBracePosition, this.clonePosition());\n\n          if (argType === 'select') {\n            return {\n              val: {\n                type: TYPE.select,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                location: location_2\n              },\n              err: null\n            };\n          } else {\n            return {\n              val: {\n                type: TYPE.plural,\n                value: value,\n                options: fromEntries(optionsResult.val),\n                offset: pluralOffset,\n                pluralType: argType === 'plural' ? 'cardinal' : 'ordinal',\n                location: location_2\n              },\n              err: null\n            };\n          }\n        }\n\n      default:\n        return this.error(ErrorKind.INVALID_ARGUMENT_TYPE, createLocation(typeStartPosition, typeEndPosition));\n    }\n  };\n\n  Parser.prototype.tryParseArgumentClose = function (openingBracePosition) {\n    // Parse: {value, number, ::currency/GBP }\n    //\n    if (this.isEOF() || this.char() !== 125\n    /* `}` */\n    ) {\n      return this.error(ErrorKind.EXPECT_ARGUMENT_CLOSING_BRACE, createLocation(openingBracePosition, this.clonePosition()));\n    }\n\n    this.bump(); // `}`\n\n    return {\n      val: true,\n      err: null\n    };\n  };\n  /**\n   * See: https://github.com/unicode-org/icu/blob/af7ed1f6d2298013dc303628438ec4abe1f16479/icu4c/source/common/messagepattern.cpp#L659\n   */\n\n\n  Parser.prototype.parseSimpleArgStyleIfPossible = function () {\n    var nestedBraces = 0;\n    var startPosition = this.clonePosition();\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      switch (ch) {\n        case 39\n        /* `'` */\n        :\n          {\n            // Treat apostrophe as quoting but include it in the style part.\n            // Find the end of the quoted literal text.\n            this.bump();\n            var apostrophePosition = this.clonePosition();\n\n            if (!this.bumpUntil(\"'\")) {\n              return this.error(ErrorKind.UNCLOSED_QUOTE_IN_ARGUMENT_STYLE, createLocation(apostrophePosition, this.clonePosition()));\n            }\n\n            this.bump();\n            break;\n          }\n\n        case 123\n        /* `{` */\n        :\n          {\n            nestedBraces += 1;\n            this.bump();\n            break;\n          }\n\n        case 125\n        /* `}` */\n        :\n          {\n            if (nestedBraces > 0) {\n              nestedBraces -= 1;\n            } else {\n              return {\n                val: this.message.slice(startPosition.offset, this.offset()),\n                err: null\n              };\n            }\n\n            break;\n          }\n\n        default:\n          this.bump();\n          break;\n      }\n    }\n\n    return {\n      val: this.message.slice(startPosition.offset, this.offset()),\n      err: null\n    };\n  };\n\n  Parser.prototype.parseNumberSkeletonFromString = function (skeleton, location) {\n    var tokens = [];\n\n    try {\n      tokens = parseNumberSkeletonFromString(skeleton);\n    } catch (e) {\n      return this.error(ErrorKind.INVALID_NUMBER_SKELETON, location);\n    }\n\n    return {\n      val: {\n        type: SKELETON_TYPE.number,\n        tokens: tokens,\n        location: location,\n        parsedOptions: this.shouldParseSkeletons ? parseNumberSkeleton(tokens) : {}\n      },\n      err: null\n    };\n  };\n  /**\n   * @param nesting_level The current nesting level of messages.\n   *     This can be positive when parsing message fragment in select or plural argument options.\n   * @param parent_arg_type The parent argument's type.\n   * @param parsed_first_identifier If provided, this is the first identifier-like selector of\n   *     the argument. It is a by-product of a previous parsing attempt.\n   * @param expecting_close_tag If true, this message is directly or indirectly nested inside\n   *     between a pair of opening and closing tags. The nested message will not parse beyond\n   *     the closing tag boundary.\n   */\n\n\n  Parser.prototype.tryParsePluralOrSelectOptions = function (nestingLevel, parentArgType, expectCloseTag, parsedFirstIdentifier) {\n    var _a;\n\n    var hasOtherClause = false;\n    var options = [];\n    var parsedSelectors = new Set();\n    var selector = parsedFirstIdentifier.value,\n        selectorLocation = parsedFirstIdentifier.location; // Parse:\n    // one {one apple}\n    // ^--^\n\n    while (true) {\n      if (selector.length === 0) {\n        var startPosition = this.clonePosition();\n\n        if (parentArgType !== 'select' && this.bumpIf('=')) {\n          // Try parse `={number}` selector\n          var result = this.tryParseDecimalInteger(ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, ErrorKind.INVALID_PLURAL_ARGUMENT_SELECTOR);\n\n          if (result.err) {\n            return result;\n          }\n\n          selectorLocation = createLocation(startPosition, this.clonePosition());\n          selector = this.message.slice(startPosition.offset, this.offset());\n        } else {\n          break;\n        }\n      } // Duplicate selector clauses\n\n\n      if (parsedSelectors.has(selector)) {\n        return this.error(parentArgType === 'select' ? ErrorKind.DUPLICATE_SELECT_ARGUMENT_SELECTOR : ErrorKind.DUPLICATE_PLURAL_ARGUMENT_SELECTOR, selectorLocation);\n      }\n\n      if (selector === 'other') {\n        hasOtherClause = true;\n      } // Parse:\n      // one {one apple}\n      //     ^----------^\n\n\n      this.bumpSpace();\n      var openingBracePosition = this.clonePosition();\n\n      if (!this.bumpIf('{')) {\n        return this.error(parentArgType === 'select' ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR_FRAGMENT : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR_FRAGMENT, createLocation(this.clonePosition(), this.clonePosition()));\n      }\n\n      var fragmentResult = this.parseMessage(nestingLevel + 1, parentArgType, expectCloseTag);\n\n      if (fragmentResult.err) {\n        return fragmentResult;\n      }\n\n      var argCloseResult = this.tryParseArgumentClose(openingBracePosition);\n\n      if (argCloseResult.err) {\n        return argCloseResult;\n      }\n\n      options.push([selector, {\n        value: fragmentResult.val,\n        location: createLocation(openingBracePosition, this.clonePosition())\n      }]); // Keep track of the existing selectors\n\n      parsedSelectors.add(selector); // Prep next selector clause.\n\n      this.bumpSpace();\n      _a = this.parseIdentifierIfPossible(), selector = _a.value, selectorLocation = _a.location;\n    }\n\n    if (options.length === 0) {\n      return this.error(parentArgType === 'select' ? ErrorKind.EXPECT_SELECT_ARGUMENT_SELECTOR : ErrorKind.EXPECT_PLURAL_ARGUMENT_SELECTOR, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n\n    if (this.requiresOtherClause && !hasOtherClause) {\n      return this.error(ErrorKind.MISSING_OTHER_CLAUSE, createLocation(this.clonePosition(), this.clonePosition()));\n    }\n\n    return {\n      val: options,\n      err: null\n    };\n  };\n\n  Parser.prototype.tryParseDecimalInteger = function (expectNumberError, invalidNumberError) {\n    var sign = 1;\n    var startingPosition = this.clonePosition();\n\n    if (this.bumpIf('+')) {} else if (this.bumpIf('-')) {\n      sign = -1;\n    }\n\n    var hasDigits = false;\n    var decimal = 0;\n\n    while (!this.isEOF()) {\n      var ch = this.char();\n\n      if (ch >= 48\n      /* `0` */\n      && ch <= 57\n      /* `9` */\n      ) {\n        hasDigits = true;\n        decimal = decimal * 10 + (ch - 48);\n        this.bump();\n      } else {\n        break;\n      }\n    }\n\n    var location = createLocation(startingPosition, this.clonePosition());\n\n    if (!hasDigits) {\n      return this.error(expectNumberError, location);\n    }\n\n    decimal *= sign;\n\n    if (!isSafeInteger(decimal)) {\n      return this.error(invalidNumberError, location);\n    }\n\n    return {\n      val: decimal,\n      err: null\n    };\n  };\n\n  Parser.prototype.offset = function () {\n    return this.position.offset;\n  };\n\n  Parser.prototype.isEOF = function () {\n    return this.offset() === this.message.length;\n  };\n\n  Parser.prototype.clonePosition = function () {\n    // This is much faster than `Object.assign` or spread.\n    return {\n      offset: this.position.offset,\n      line: this.position.line,\n      column: this.position.column\n    };\n  };\n  /**\n   * Return the code point at the current position of the parser.\n   * Throws if the index is out of bound.\n   */\n\n\n  Parser.prototype.char = function () {\n    var offset = this.position.offset;\n\n    if (offset >= this.message.length) {\n      throw Error('out of bound');\n    }\n\n    var code = codePointAt(this.message, offset);\n\n    if (code === undefined) {\n      throw Error(\"Offset \".concat(offset, \" is at invalid UTF-16 code unit boundary\"));\n    }\n\n    return code;\n  };\n\n  Parser.prototype.error = function (kind, location) {\n    return {\n      val: null,\n      err: {\n        kind: kind,\n        message: this.message,\n        location: location\n      }\n    };\n  };\n  /** Bump the parser to the next UTF-16 code unit. */\n\n\n  Parser.prototype.bump = function () {\n    if (this.isEOF()) {\n      return;\n    }\n\n    var code = this.char();\n\n    if (code === 10\n    /* '\\n' */\n    ) {\n      this.position.line += 1;\n      this.position.column = 1;\n      this.position.offset += 1;\n    } else {\n      this.position.column += 1; // 0 ~ 0x10000 -> unicode BMP, otherwise skip the surrogate pair.\n\n      this.position.offset += code < 0x10000 ? 1 : 2;\n    }\n  };\n  /**\n   * If the substring starting at the current position of the parser has\n   * the given prefix, then bump the parser to the character immediately\n   * following the prefix and return true. Otherwise, don't bump the parser\n   * and return false.\n   */\n\n\n  Parser.prototype.bumpIf = function (prefix) {\n    if (startsWith(this.message, prefix, this.offset())) {\n      for (var i = 0; i < prefix.length; i++) {\n        this.bump();\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Bump the parser until the pattern character is found and return `true`.\n   * Otherwise bump to the end of the file and return `false`.\n   */\n\n\n  Parser.prototype.bumpUntil = function (pattern) {\n    var currentOffset = this.offset();\n    var index = this.message.indexOf(pattern, currentOffset);\n\n    if (index >= 0) {\n      this.bumpTo(index);\n      return true;\n    } else {\n      this.bumpTo(this.message.length);\n      return false;\n    }\n  };\n  /**\n   * Bump the parser to the target offset.\n   * If target offset is beyond the end of the input, bump the parser to the end of the input.\n   */\n\n\n  Parser.prototype.bumpTo = function (targetOffset) {\n    if (this.offset() > targetOffset) {\n      throw Error(\"targetOffset \".concat(targetOffset, \" must be greater than or equal to the current offset \").concat(this.offset()));\n    }\n\n    targetOffset = Math.min(targetOffset, this.message.length);\n\n    while (true) {\n      var offset = this.offset();\n\n      if (offset === targetOffset) {\n        break;\n      }\n\n      if (offset > targetOffset) {\n        throw Error(\"targetOffset \".concat(targetOffset, \" is at invalid UTF-16 code unit boundary\"));\n      }\n\n      this.bump();\n\n      if (this.isEOF()) {\n        break;\n      }\n    }\n  };\n  /** advance the parser through all whitespace to the next non-whitespace code unit. */\n\n\n  Parser.prototype.bumpSpace = function () {\n    while (!this.isEOF() && _isWhiteSpace(this.char())) {\n      this.bump();\n    }\n  };\n  /**\n   * Peek at the *next* Unicode codepoint in the input without advancing the parser.\n   * If the input has been exhausted, then this returns null.\n   */\n\n\n  Parser.prototype.peek = function () {\n    if (this.isEOF()) {\n      return null;\n    }\n\n    var code = this.char();\n    var offset = this.offset();\n    var nextCode = this.message.charCodeAt(offset + (code >= 0x10000 ? 2 : 1));\n    return nextCode !== null && nextCode !== void 0 ? nextCode : null;\n  };\n\n  return Parser;\n}();\n\nexport { Parser };\n/**\n * This check if codepoint is alphabet (lower & uppercase)\n * @param codepoint\n * @returns\n */\n\nfunction _isAlpha(codepoint) {\n  return codepoint >= 97 && codepoint <= 122 || codepoint >= 65 && codepoint <= 90;\n}\n\nfunction _isAlphaOrSlash(codepoint) {\n  return _isAlpha(codepoint) || codepoint === 47;\n  /* '/' */\n}\n/** See `parseTag` function docs. */\n\n\nfunction _isPotentialElementNameChar(c) {\n  return c === 45\n  /* '-' */\n  || c === 46\n  /* '.' */\n  || c >= 48 && c <= 57\n  /* 0..9 */\n  || c === 95\n  /* '_' */\n  || c >= 97 && c <= 122\n  /** a..z */\n  || c >= 65 && c <= 90\n  /* A..Z */\n  || c == 0xb7 || c >= 0xc0 && c <= 0xd6 || c >= 0xd8 && c <= 0xf6 || c >= 0xf8 && c <= 0x37d || c >= 0x37f && c <= 0x1fff || c >= 0x200c && c <= 0x200d || c >= 0x203f && c <= 0x2040 || c >= 0x2070 && c <= 0x218f || c >= 0x2c00 && c <= 0x2fef || c >= 0x3001 && c <= 0xd7ff || c >= 0xf900 && c <= 0xfdcf || c >= 0xfdf0 && c <= 0xfffd || c >= 0x10000 && c <= 0xeffff;\n}\n/**\n * Code point equivalent of regex `\\p{White_Space}`.\n * From: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\n\n\nfunction _isWhiteSpace(c) {\n  return c >= 0x0009 && c <= 0x000d || c === 0x0020 || c === 0x0085 || c >= 0x200e && c <= 0x200f || c === 0x2028 || c === 0x2029;\n}\n/**\n * Code point equivalent of regex `\\p{Pattern_Syntax}`.\n * See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt\n */\n\n\nfunction _isPatternSyntax(c) {\n  return c >= 0x0021 && c <= 0x0023 || c === 0x0024 || c >= 0x0025 && c <= 0x0027 || c === 0x0028 || c === 0x0029 || c === 0x002a || c === 0x002b || c === 0x002c || c === 0x002d || c >= 0x002e && c <= 0x002f || c >= 0x003a && c <= 0x003b || c >= 0x003c && c <= 0x003e || c >= 0x003f && c <= 0x0040 || c === 0x005b || c === 0x005c || c === 0x005d || c === 0x005e || c === 0x0060 || c === 0x007b || c === 0x007c || c === 0x007d || c === 0x007e || c === 0x00a1 || c >= 0x00a2 && c <= 0x00a5 || c === 0x00a6 || c === 0x00a7 || c === 0x00a9 || c === 0x00ab || c === 0x00ac || c === 0x00ae || c === 0x00b0 || c === 0x00b1 || c === 0x00b6 || c === 0x00bb || c === 0x00bf || c === 0x00d7 || c === 0x00f7 || c >= 0x2010 && c <= 0x2015 || c >= 0x2016 && c <= 0x2017 || c === 0x2018 || c === 0x2019 || c === 0x201a || c >= 0x201b && c <= 0x201c || c === 0x201d || c === 0x201e || c === 0x201f || c >= 0x2020 && c <= 0x2027 || c >= 0x2030 && c <= 0x2038 || c === 0x2039 || c === 0x203a || c >= 0x203b && c <= 0x203e || c >= 0x2041 && c <= 0x2043 || c === 0x2044 || c === 0x2045 || c === 0x2046 || c >= 0x2047 && c <= 0x2051 || c === 0x2052 || c === 0x2053 || c >= 0x2055 && c <= 0x205e || c >= 0x2190 && c <= 0x2194 || c >= 0x2195 && c <= 0x2199 || c >= 0x219a && c <= 0x219b || c >= 0x219c && c <= 0x219f || c === 0x21a0 || c >= 0x21a1 && c <= 0x21a2 || c === 0x21a3 || c >= 0x21a4 && c <= 0x21a5 || c === 0x21a6 || c >= 0x21a7 && c <= 0x21ad || c === 0x21ae || c >= 0x21af && c <= 0x21cd || c >= 0x21ce && c <= 0x21cf || c >= 0x21d0 && c <= 0x21d1 || c === 0x21d2 || c === 0x21d3 || c === 0x21d4 || c >= 0x21d5 && c <= 0x21f3 || c >= 0x21f4 && c <= 0x22ff || c >= 0x2300 && c <= 0x2307 || c === 0x2308 || c === 0x2309 || c === 0x230a || c === 0x230b || c >= 0x230c && c <= 0x231f || c >= 0x2320 && c <= 0x2321 || c >= 0x2322 && c <= 0x2328 || c === 0x2329 || c === 0x232a || c >= 0x232b && c <= 0x237b || c === 0x237c || c >= 0x237d && c <= 0x239a || c >= 0x239b && c <= 0x23b3 || c >= 0x23b4 && c <= 0x23db || c >= 0x23dc && c <= 0x23e1 || c >= 0x23e2 && c <= 0x2426 || c >= 0x2427 && c <= 0x243f || c >= 0x2440 && c <= 0x244a || c >= 0x244b && c <= 0x245f || c >= 0x2500 && c <= 0x25b6 || c === 0x25b7 || c >= 0x25b8 && c <= 0x25c0 || c === 0x25c1 || c >= 0x25c2 && c <= 0x25f7 || c >= 0x25f8 && c <= 0x25ff || c >= 0x2600 && c <= 0x266e || c === 0x266f || c >= 0x2670 && c <= 0x2767 || c === 0x2768 || c === 0x2769 || c === 0x276a || c === 0x276b || c === 0x276c || c === 0x276d || c === 0x276e || c === 0x276f || c === 0x2770 || c === 0x2771 || c === 0x2772 || c === 0x2773 || c === 0x2774 || c === 0x2775 || c >= 0x2794 && c <= 0x27bf || c >= 0x27c0 && c <= 0x27c4 || c === 0x27c5 || c === 0x27c6 || c >= 0x27c7 && c <= 0x27e5 || c === 0x27e6 || c === 0x27e7 || c === 0x27e8 || c === 0x27e9 || c === 0x27ea || c === 0x27eb || c === 0x27ec || c === 0x27ed || c === 0x27ee || c === 0x27ef || c >= 0x27f0 && c <= 0x27ff || c >= 0x2800 && c <= 0x28ff || c >= 0x2900 && c <= 0x2982 || c === 0x2983 || c === 0x2984 || c === 0x2985 || c === 0x2986 || c === 0x2987 || c === 0x2988 || c === 0x2989 || c === 0x298a || c === 0x298b || c === 0x298c || c === 0x298d || c === 0x298e || c === 0x298f || c === 0x2990 || c === 0x2991 || c === 0x2992 || c === 0x2993 || c === 0x2994 || c === 0x2995 || c === 0x2996 || c === 0x2997 || c === 0x2998 || c >= 0x2999 && c <= 0x29d7 || c === 0x29d8 || c === 0x29d9 || c === 0x29da || c === 0x29db || c >= 0x29dc && c <= 0x29fb || c === 0x29fc || c === 0x29fd || c >= 0x29fe && c <= 0x2aff || c >= 0x2b00 && c <= 0x2b2f || c >= 0x2b30 && c <= 0x2b44 || c >= 0x2b45 && c <= 0x2b46 || c >= 0x2b47 && c <= 0x2b4c || c >= 0x2b4d && c <= 0x2b73 || c >= 0x2b74 && c <= 0x2b75 || c >= 0x2b76 && c <= 0x2b95 || c === 0x2b96 || c >= 0x2b97 && c <= 0x2bff || c >= 0x2e00 && c <= 0x2e01 || c === 0x2e02 || c === 0x2e03 || c === 0x2e04 || c === 0x2e05 || c >= 0x2e06 && c <= 0x2e08 || c === 0x2e09 || c === 0x2e0a || c === 0x2e0b || c === 0x2e0c || c === 0x2e0d || c >= 0x2e0e && c <= 0x2e16 || c === 0x2e17 || c >= 0x2e18 && c <= 0x2e19 || c === 0x2e1a || c === 0x2e1b || c === 0x2e1c || c === 0x2e1d || c >= 0x2e1e && c <= 0x2e1f || c === 0x2e20 || c === 0x2e21 || c === 0x2e22 || c === 0x2e23 || c === 0x2e24 || c === 0x2e25 || c === 0x2e26 || c === 0x2e27 || c === 0x2e28 || c === 0x2e29 || c >= 0x2e2a && c <= 0x2e2e || c === 0x2e2f || c >= 0x2e30 && c <= 0x2e39 || c >= 0x2e3a && c <= 0x2e3b || c >= 0x2e3c && c <= 0x2e3f || c === 0x2e40 || c === 0x2e41 || c === 0x2e42 || c >= 0x2e43 && c <= 0x2e4f || c >= 0x2e50 && c <= 0x2e51 || c === 0x2e52 || c >= 0x2e53 && c <= 0x2e7f || c >= 0x3001 && c <= 0x3003 || c === 0x3008 || c === 0x3009 || c === 0x300a || c === 0x300b || c === 0x300c || c === 0x300d || c === 0x300e || c === 0x300f || c === 0x3010 || c === 0x3011 || c >= 0x3012 && c <= 0x3013 || c === 0x3014 || c === 0x3015 || c === 0x3016 || c === 0x3017 || c === 0x3018 || c === 0x3019 || c === 0x301a || c === 0x301b || c === 0x301c || c === 0x301d || c >= 0x301e && c <= 0x301f || c === 0x3020 || c === 0x3030 || c === 0xfd3e || c === 0xfd3f || c >= 0xfe45 && c <= 0xfe46;\n}","import { __assign } from \"tslib\";\nimport { ErrorKind } from './error';\nimport { Parser } from './parser';\nimport { isDateElement, isDateTimeSkeleton, isNumberElement, isNumberSkeleton, isPluralElement, isSelectElement, isTagElement, isTimeElement } from './types';\n\nfunction pruneLocation(els) {\n  els.forEach(function (el) {\n    delete el.location;\n\n    if (isSelectElement(el) || isPluralElement(el)) {\n      for (var k in el.options) {\n        delete el.options[k].location;\n        pruneLocation(el.options[k].value);\n      }\n    } else if (isNumberElement(el) && isNumberSkeleton(el.style)) {\n      delete el.style.location;\n    } else if ((isDateElement(el) || isTimeElement(el)) && isDateTimeSkeleton(el.style)) {\n      delete el.style.location;\n    } else if (isTagElement(el)) {\n      pruneLocation(el.children);\n    }\n  });\n}\n\nexport function parse(message, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  opts = __assign({\n    shouldParseSkeletons: true,\n    requiresOtherClause: true\n  }, opts);\n  var result = new Parser(message, opts).parse();\n\n  if (result.err) {\n    var error = SyntaxError(ErrorKind[result.err.kind]); // @ts-expect-error Assign to error object\n\n    error.location = result.err.location; // @ts-expect-error Assign to error object\n\n    error.originalMessage = result.err.message;\n    throw error;\n  }\n\n  if (!(opts === null || opts === void 0 ? void 0 : opts.captureLocation)) {\n    pruneLocation(result.val);\n  }\n\n  return result.val;\n}\nexport * from './types';","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.generateENXB = exports.generateENXA = exports.generateXXHA = exports.generateXXAC = exports.generateXXLS = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar icu_messageformat_parser_1 = require(\"@formatjs/icu-messageformat-parser\");\n\nfunction generateXXLS(msg) {\n  var ast = typeof msg === 'string' ? (0, icu_messageformat_parser_1.parse)(msg) : msg;\n  var lastChunk = ast.pop();\n\n  if (lastChunk && (0, icu_messageformat_parser_1.isLiteralElement)(lastChunk)) {\n    lastChunk.value += 'SSSSSSSSSSSSSSSSSSSSSSSSS';\n    return (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], ast, true), [lastChunk], false);\n  }\n\n  return (0, tslib_1.__spreadArray)((0, tslib_1.__spreadArray)([], ast, true), [{\n    type: icu_messageformat_parser_1.TYPE.literal,\n    value: 'SSSSSSSSSSSSSSSSSSSSSSSSS'\n  }], false);\n}\n\nexports.generateXXLS = generateXXLS;\n\nfunction generateXXAC(msg) {\n  var ast = typeof msg === 'string' ? (0, icu_messageformat_parser_1.parse)(msg) : msg;\n  ast.forEach(function (el) {\n    if ((0, icu_messageformat_parser_1.isLiteralElement)(el)) {\n      el.value = el.value.toUpperCase();\n    } else if ((0, icu_messageformat_parser_1.isPluralElement)(el) || (0, icu_messageformat_parser_1.isSelectElement)(el)) {\n      for (var _i = 0, _a = Object.values(el.options); _i < _a.length; _i++) {\n        var opt = _a[_i];\n        generateXXAC(opt.value);\n      }\n    } else if ((0, icu_messageformat_parser_1.isTagElement)(el)) {\n      generateXXAC(el.children);\n    }\n  });\n  return ast;\n}\n\nexports.generateXXAC = generateXXAC;\n\nfunction generateXXHA(msg) {\n  var ast = typeof msg === 'string' ? (0, icu_messageformat_parser_1.parse)(msg) : msg;\n  var firstChunk = ast.shift();\n\n  if (firstChunk && (0, icu_messageformat_parser_1.isLiteralElement)(firstChunk)) {\n    firstChunk.value = '[javascript]' + firstChunk.value;\n    return (0, tslib_1.__spreadArray)([firstChunk], ast, true);\n  }\n\n  return (0, tslib_1.__spreadArray)([{\n    type: icu_messageformat_parser_1.TYPE.literal,\n    value: '[javascript]'\n  }], ast, true);\n}\n\nexports.generateXXHA = generateXXHA;\nvar ASCII = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\nvar ACCENTED_ASCII = 'âḃćḋèḟĝḫíĵǩĺṁńŏṗɋŕśṭůṿẘẋẏẓḀḂḈḊḔḞḠḢḬĴḴĻḾŊÕṔɊŔṠṮŨṼẄẌŸƵ';\n\nfunction generateENXA(msg) {\n  var ast = typeof msg === 'string' ? (0, icu_messageformat_parser_1.parse)(msg) : msg;\n  ast.forEach(function (el) {\n    if ((0, icu_messageformat_parser_1.isLiteralElement)(el)) {\n      el.value = el.value.split('').map(function (c) {\n        var i = ASCII.indexOf(c);\n\n        if (i < 0) {\n          return c;\n        }\n\n        return ACCENTED_ASCII[i];\n      }).join('');\n    } else if ((0, icu_messageformat_parser_1.isPluralElement)(el) || (0, icu_messageformat_parser_1.isSelectElement)(el)) {\n      for (var _i = 0, _a = Object.values(el.options); _i < _a.length; _i++) {\n        var opt = _a[_i];\n        generateENXA(opt.value);\n      }\n    } else if ((0, icu_messageformat_parser_1.isTagElement)(el)) {\n      generateENXA(el.children);\n    }\n  });\n  return ast;\n}\n\nexports.generateENXA = generateENXA;\n\nfunction generateENXB(msg) {\n  var ast = typeof msg === 'string' ? (0, icu_messageformat_parser_1.parse)(msg) : msg;\n  ast.forEach(function (el) {\n    if ((0, icu_messageformat_parser_1.isLiteralElement)(el)) {\n      var pseudoString = el.value.split('').map(function (c, index) {\n        var i = ASCII.indexOf(c);\n        var canPad = (index + 1) % 3 === 0;\n\n        if (i < 0) {\n          return c;\n        }\n\n        return canPad ? ACCENTED_ASCII[i].repeat(3) : ACCENTED_ASCII[i];\n      }).join('');\n      el.value = \"[!! \".concat(pseudoString, \" !!]\");\n    } else if ((0, icu_messageformat_parser_1.isPluralElement)(el) || (0, icu_messageformat_parser_1.isSelectElement)(el)) {\n      for (var _i = 0, _a = Object.values(el.options); _i < _a.length; _i++) {\n        var opt = _a[_i];\n        generateENXB(opt.value);\n      }\n    } else if ((0, icu_messageformat_parser_1.isTagElement)(el)) {\n      generateENXB(el.children);\n    }\n  });\n  return ast;\n}\n\nexports.generateENXB = generateENXB;"],"sourceRoot":""}